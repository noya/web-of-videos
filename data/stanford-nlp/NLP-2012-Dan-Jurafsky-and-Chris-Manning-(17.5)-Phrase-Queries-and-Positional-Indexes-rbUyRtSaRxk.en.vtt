WEBVTT
Kind: captions
Language: en

00:00:01.210 --> 00:00:04.130
In this segment I'm going to
introduce phrase queries which

00:00:04.130 --> 00:00:08.740
in practice have been the most important
kind of extended Boolean query.

00:00:08.740 --> 00:00:11.420
And then examine how you need to extend

00:00:11.420 --> 00:00:15.740
inverted index data structure to
be able to handle phrase queries.

00:00:17.460 --> 00:00:21.710
So very often we'd like to query
not only for individual words but

00:00:21.710 --> 00:00:23.870
also for multi-word units.

00:00:23.870 --> 00:00:28.000
Many useful things that we want
to query on a multi-word units.

00:00:28.000 --> 00:00:30.880
So information retrieval
is multi-word unit.

00:00:30.880 --> 00:00:36.130
Well, many, many other things like
organization names Stanford University.

00:00:36.130 --> 00:00:40.630
So, what we want to do is have
a mechanism where we can see, say,

00:00:40.630 --> 00:00:46.140
let's match these pair of words as
a unit and the syntax that's standardly

00:00:46.140 --> 00:00:51.500
used in modern web search engines is
to put it in inverted quotes like that.

00:00:51.500 --> 00:00:55.030
And so
if we have that kind of phrase as a query,

00:00:55.030 --> 00:00:58.110
then what we're going to say
is a document that says I went

00:00:58.110 --> 00:01:02.470
to university at Stanford
doesn't match that phrase query.

00:01:02.470 --> 00:01:07.200
So this notion of putting
things in inverted commas

00:01:07.200 --> 00:01:11.100
has proven to be very
easily understood by users.

00:01:11.100 --> 00:01:15.750
Something that information retrieval
system designers generally

00:01:15.750 --> 00:01:20.210
lament is that when people design
advanced search functionality for

00:01:20.210 --> 00:01:23.140
their systems that almost nobody uses it.

00:01:23.140 --> 00:01:27.770
Just a few people like me and
academics and people like that, but

00:01:27.770 --> 00:01:29.590
regular users just don't use it.

00:01:29.590 --> 00:01:32.490
And really this notion of
phrase querying is sort of

00:01:32.490 --> 00:01:37.090
the newest thing to an exception, that
it is fairly widely understood and used.

00:01:37.090 --> 00:01:42.950
But I'll point out, that as well
as overt phrase queries like this,

00:01:42.950 --> 00:01:45.740
there's actually another
interesting phenomenon

00:01:45.740 --> 00:01:49.790
is that many of the queries
are implicit phrase queries.

00:01:49.790 --> 00:01:55.460
So someone will give us their query
San Francisco or something like that.

00:01:55.460 --> 00:02:00.660
And well, really what they want to do
is have it interpreted as a phrase,

00:02:00.660 --> 00:02:06.150
but they just didn't bother or know to
put the inverted quotes around that.

00:02:06.150 --> 00:02:10.270
So, in modern web search
engines an active area of

00:02:10.270 --> 00:02:15.660
research has been how to identify these
implicit phrases and take advantage of

00:02:15.660 --> 00:02:20.310
knowing it's an implicit phrase,
to alter what documents get returned.

00:02:20.310 --> 00:02:22.140
But we're going to leave that aside for
the moment,

00:02:22.140 --> 00:02:27.090
and we're just going to deal with these
explicit phrases, and work out how

00:02:27.090 --> 00:02:30.960
we can do a good job at matching them
with our information retrieval system.

00:02:32.690 --> 00:02:37.130
Okay, well first what should be clear
is that it no longer suffices to

00:02:37.130 --> 00:02:41.750
store just a term and a posting's
list of documents for each term.

00:02:41.750 --> 00:02:43.440
Because if we have only that,

00:02:43.440 --> 00:02:48.530
we can easily find documents that contain
two terms but we have no idea whether

00:02:48.530 --> 00:02:52.250
the terms are adjacent to each
other as a phrase in that document.

00:02:52.250 --> 00:02:56.550
The only way we could do it is
by exhaustive post-processing of

00:02:56.550 --> 00:03:00.880
candidate documents to see if they
actually did contain the phrase and that

00:03:00.880 --> 00:03:04.790
would be extremely slow because we would
be back to linear scanning of documents.

00:03:07.390 --> 00:03:11.490
One way to solve this problem
is the idea of a biword index.

00:03:11.490 --> 00:03:16.000
So, for a biword index,
what we do is we index every

00:03:16.000 --> 00:03:20.000
consecutive pair of terms as a phrase.

00:03:20.000 --> 00:03:24.900
So for example if we have this text here,
Friends, Romans, Countrymen,

00:03:24.900 --> 00:03:29.610
we generate the biwords of adjacent
words of friends and romans.

00:03:30.670 --> 00:03:36.130
And then we generate the biword
of romans countrymen and

00:03:36.130 --> 00:03:40.340
each of these biwords is
now a dictionary term.

00:03:40.340 --> 00:03:41.560
And so what does that mean?

00:03:41.560 --> 00:03:48.040
Well that means that for each of these we
would say that friends romans occurs in,

00:03:48.040 --> 00:03:55.340
let's say this is document 17 and
maybe it also occurs in documents 33 and

00:03:55.340 --> 00:04:01.940
romans countrymen occurs in document 17
and it might occur in some other document.

00:04:07.040 --> 00:04:12.230
Well, if we build that,
two word phrase querying is now immediate,

00:04:12.230 --> 00:04:16.920
because if we want to find
documents that contain friends,

00:04:16.920 --> 00:04:20.710
romans in them, we can just look
up this dictionary entry and

00:04:20.710 --> 00:04:23.760
then grab the postings list
that was returned for it.

00:04:25.500 --> 00:04:32.730
If we consider more complex cases,
we can even basically handle those.

00:04:32.730 --> 00:04:37.530
So we can handle longer phrase
queries by breaking them down.

00:04:37.530 --> 00:04:42.691
So if our phrase query is
stanford university palo alto,

00:04:42.691 --> 00:04:48.174
we can break it up into an AND
query of stanford university AND

00:04:48.174 --> 00:04:51.170
university palo AND Palo Alto.

00:04:51.170 --> 00:04:54.180
And so we can use our byword index to

00:04:54.180 --> 00:04:58.310
find documents that contain
all three of these bigrams.

00:04:58.310 --> 00:05:01.070
Now that's not going to be perfect.

00:05:01.070 --> 00:05:04.100
Without doing a linear
scan through the docs,

00:05:04.100 --> 00:05:09.370
we can't be sure that the documents
that we're returning actually have this

00:05:09.370 --> 00:05:12.320
continuous phrase stanford
university palo alto.

00:05:12.320 --> 00:05:15.227
But it seems highly likely that they will,

00:05:15.227 --> 00:05:20.510
because we've checked that each
of these bigrams occurring.

00:05:20.510 --> 00:05:23.310
So there's a small chance
of false positives, but

00:05:23.310 --> 00:05:26.205
it seems like we're in
a pretty good state.

00:05:29.270 --> 00:05:33.400
So one of the issues with
using a biword index, well,

00:05:33.400 --> 00:05:37.030
as we noted before, there can be
false positives in what's returned.

00:05:37.030 --> 00:05:40.020
But maybe that's not such a big problem.

00:05:40.020 --> 00:05:44.910
The big problem is that there's
this enormous blow up of the index,

00:05:44.910 --> 00:05:47.520
because our dictionary has
gotten much more massive.

00:05:47.520 --> 00:05:52.420
So that means that it's not
practical to have triword and

00:05:52.420 --> 00:05:57.700
quadword indices to actually
exactly match long queries.

00:05:57.700 --> 00:06:00.870
But even for biwords we then potentially

00:06:02.010 --> 00:06:06.060
have the space of words squared
of possible dictionary entries.

00:06:06.060 --> 00:06:10.690
So because of that, biword indices
are not the standard solution for

00:06:10.690 --> 00:06:12.450
handling free searching.

00:06:12.450 --> 00:06:15.956
But as I'll show, it wasn't useless
that I explained them to you,

00:06:15.956 --> 00:06:20.280
because as I'll show at the end, they can
be an important component of a solution.

00:06:22.858 --> 00:06:25.020
So what is the standard solution?

00:06:25.020 --> 00:06:28.690
The standard solution is to move
to having the positional index.

00:06:28.690 --> 00:06:32.635
So the idea of the positional
index is that in the postings we

00:06:32.635 --> 00:06:37.120
store not only the documents
that contain the term, but

00:06:37.120 --> 00:06:42.430
also the position in each
document where the term appears.

00:06:42.430 --> 00:06:47.570
So, the organization of what we
have now is in the dictionary.

00:06:47.570 --> 00:06:49.270
We have a term.

00:06:49.270 --> 00:06:52.310
And the document frequency of the term.

00:06:52.310 --> 00:06:55.610
And then when we point off
to the postings lists,

00:06:55.610 --> 00:06:59.720
then instead of just having
a list of document IDs.

00:06:59.720 --> 00:07:04.300
We then have a list of
document IDs where for

00:07:04.300 --> 00:07:09.290
each document we then have a list
of positions where the term occurs.

00:07:09.290 --> 00:07:11.540
Let's look at that
concretely with an example.

00:07:12.820 --> 00:07:20.030
So, here we have the word be, which
occurs in almost a million documents.

00:07:20.030 --> 00:07:21.601
And then we have where.

00:07:21.601 --> 00:07:26.580
So, in document 1,
it occurs at word 7, 18, 33, etc.

00:07:26.580 --> 00:07:31.730
Document 2 it occurs in
these two word positions.

00:07:31.730 --> 00:07:34.110
It doesn't occur in document three.

00:07:34.110 --> 00:07:38.070
Document 4,
it occurs in a bunch of places, and so on.

00:07:38.070 --> 00:07:44.620
And so with these, we can then be
able to check where the phrases

00:07:44.620 --> 00:07:49.500
occur by then seeing where the words
occur adjacent to each other.

00:07:49.500 --> 00:07:55.180
To get the idea of that, you could
consider this little question here.

00:07:55.180 --> 00:08:00.680
So which of these four documents
could contain to be or

00:08:00.680 --> 00:08:03.610
not to be based on those
document positions.

00:08:03.610 --> 00:08:06.950
Now obviously we haven't seen the postings
list for the other words, but

00:08:06.950 --> 00:08:10.520
just looking at where be occurs
which document is a candidate.

00:08:12.950 --> 00:08:17.940
So with this kind of data structure,
we can handle phrase queries

00:08:17.940 --> 00:08:21.860
using a merge algorithm
much as we showed before.

00:08:21.860 --> 00:08:25.220
It's just a little bit hairier
because rather than just

00:08:25.220 --> 00:08:29.500
doing an intersection of the document IDs,
we have to do this sort of two-level

00:08:29.500 --> 00:08:34.970
algorithm where we both intersect
the document IDs and then also check that

00:08:34.970 --> 00:08:39.630
there are compatible positions for
the words occurring in a phrase.

00:08:39.630 --> 00:08:44.390
And so that means that we need to deal
with a bit more than just equalities.

00:08:44.390 --> 00:08:49.583
So for
example if we're wanting to find instances

00:08:49.583 --> 00:08:53.664
of the phrase information retrieval,

00:08:53.664 --> 00:08:58.113
what we want is that if
the word information

00:08:58.113 --> 00:09:03.057
occurs at position 37
in a certain document,

00:09:03.057 --> 00:09:09.756
you want retrieval appearing at
position 38 in the document.

00:09:09.756 --> 00:09:12.426
So going through that in
slightly more detail.

00:09:12.426 --> 00:09:18.836
To process a phrase query, what we do is,
so let's assume our phrase is to be or

00:09:18.836 --> 00:09:22.840
not to be that we want to
find in inverted commas.

00:09:24.520 --> 00:09:30.380
So we get the postings list of
each of the individual terms and

00:09:30.380 --> 00:09:34.960
then what we're going to do is we're
going to progressively intersect them.

00:09:34.960 --> 00:09:37.580
So if we start of with the to be,

00:09:37.580 --> 00:09:42.340
we're going to start at
the beginning doing postings merge.

00:09:42.340 --> 00:09:43.770
And we're saying, well,

00:09:43.770 --> 00:09:49.330
document 1 can't be a candidate because it
doesn't appear on the other postings list.

00:09:49.330 --> 00:09:55.070
Document 2 can't be a candidate because it
doesn't appear on the other postings list.

00:09:55.070 --> 00:09:57.660
And then at this point,
we've got to document 4.

00:09:57.660 --> 00:09:59.380
And the doc IDs match.

00:09:59.380 --> 00:10:04.440
But then that this point, with the
positional query, we have to recurse, and

00:10:04.440 --> 00:10:10.590
then do another merge algorithm for
the positions within the postings list.

00:10:10.590 --> 00:10:14.010
So we start here and here, but this time,

00:10:14.010 --> 00:10:19.640
rather than a quality check what we're
wanting to see is can we find a place

00:10:19.640 --> 00:10:25.710
where be occurs with a token
number one larger than two.

00:10:25.710 --> 00:10:27.769
So we'll again step along.

00:10:27.769 --> 00:10:32.390
And we'll say well here's one candidate,
190 and 191.

00:10:32.390 --> 00:10:37.405
And here's a second candidate 429 and 430.

00:10:37.405 --> 00:10:41.346
So those will be two candidate
matches inside document 4, and so

00:10:41.346 --> 00:10:46.865
we'll be returning both of those candidate
matches separately, because we're actually

00:10:46.865 --> 00:10:51.308
finding the positions in documents
where our phrase query is matching and

00:10:51.308 --> 00:10:56.120
that we'll need to refine with
the other query words coming up ahead.

00:10:56.120 --> 00:10:58.720
At that point we then revert back.

00:10:59.720 --> 00:11:02.130
Wait, no, sorry, I'm wrong,
there's one more candidate.

00:11:02.130 --> 00:11:03.730
Sorry, they're three candidates here,
right?

00:11:04.870 --> 00:11:11.150
But once we've exhausted the positions
in one document, we then revert up to

00:11:11.150 --> 00:11:17.610
the higher level of our postings merge,
and then we say five is less than seven.

00:11:17.610 --> 00:11:22.904
So, this gets crossed off, and then we
advance that pointer and proceed along.

00:11:22.904 --> 00:11:26.923
And I hope you can see that actually
this method works not only for

00:11:26.923 --> 00:11:30.049
phrase queries where
the words are offset by one,

00:11:30.049 --> 00:11:34.664
but you'd actually use exactly the same
method for the proximity queries

00:11:34.664 --> 00:11:38.682
that we saw early with the Westlaw
servers where you could ask for

00:11:38.682 --> 00:11:43.472
one word being within three words of
another word, or something like that.

00:11:46.746 --> 00:11:49.490
All right, so
that was the examples like this.

00:11:49.490 --> 00:11:53.490
So here we had limit within three words

00:11:53.490 --> 00:11:58.570
of statute which is within three words
of federal, within two words of tort.

00:11:58.570 --> 00:12:03.190
So, we could use the same kind of
techniques of optimizing the query.

00:12:03.190 --> 00:12:05.360
That if we started with this one,

00:12:05.360 --> 00:12:09.510
we are then having a condition
on how close together

00:12:09.510 --> 00:12:14.650
the token position indexes have to be
to count as a match within a document.

00:12:14.650 --> 00:12:19.910
And so clearly positional indexes can be
used for these kind of proximity queries,

00:12:19.910 --> 00:12:22.650
where biword indexes do nothing for you.

00:12:24.520 --> 00:12:29.480
So I've sort of set the algorithm here,
but it's something that

00:12:29.480 --> 00:12:34.390
you might want to work through very
concretely is how you can change

00:12:34.390 --> 00:12:39.110
the linear postings merge algorithms
to handle proximity queries.

00:12:39.110 --> 00:12:43.970
In particular you can think about how
to get it to work for any value of k.

00:12:43.970 --> 00:12:47.630
It's actually a little bit tricky to
do this correctly and efficiently.

00:12:47.630 --> 00:12:53.610
Because you can have the within k words
matching on either side of the word and

00:12:53.610 --> 00:12:58.310
you have to keep track of things for
the right number of words on each side.

00:12:58.310 --> 00:13:01.480
It'd be good to try and
work out by yourself, but

00:13:01.480 --> 00:13:07.250
you can also see one example of an answer
in the figure 2.12 about Introduction

00:13:07.250 --> 00:13:10.680
to Information Retrieval book which you
can find free on the web to look at.

00:13:13.360 --> 00:13:18.490
So positional index is great because it
allows us to answer phrase queries and

00:13:18.490 --> 00:13:20.110
proximity queries.

00:13:20.110 --> 00:13:22.490
But there's a cost to a positional index,

00:13:22.490 --> 00:13:26.030
which is that our postings
list just got a lot larger.

00:13:26.030 --> 00:13:28.920
Because rather than only
storing document IDs,

00:13:28.920 --> 00:13:34.670
they're storing document IDs and
the offsets of tokens within the document.

00:13:34.670 --> 00:13:38.424
And that's a major factor,
even though indices can be compressed.

00:13:39.555 --> 00:13:45.520
Nevertheless, it's now completely standard
to use a positional index because of

00:13:45.520 --> 00:13:51.497
the power and flexibility you can get from
handling phrase and proximity queries.

00:13:51.497 --> 00:13:56.941
Whether they're being used explicitly
in terms of having these kind of phrase

00:13:56.941 --> 00:14:02.222
queries or within three queries, or
whether they're just being exploited

00:14:02.222 --> 00:14:07.518
to improve the ranking of a system when
it's looking for implicit phrases.

00:14:07.518 --> 00:14:11.161
But as I said,
the positional index gets much larger.

00:14:11.161 --> 00:14:17.601
And so when we're estimating the size of
a positional index, we note that there

00:14:17.601 --> 00:14:22.660
has to be an entry for each occurrence
of a word, not just once a document.

00:14:22.660 --> 00:14:26.260
So what that means is that
the size of the index

00:14:26.260 --> 00:14:29.820
depends on the average
length of the documents now.

00:14:29.820 --> 00:14:35.020
So, if we have fairly short documents.

00:14:35.020 --> 00:14:38.550
It's not such a big deal,
because actually most of the words

00:14:38.550 --> 00:14:42.410
that occur in a document
occur only once or twice.

00:14:42.410 --> 00:14:44.680
But if we have very long documents,

00:14:44.680 --> 00:14:48.460
then that blows out the size of
the positional index rather more.

00:14:48.460 --> 00:14:54.733
So for example, you can consider a word
with a common word frequency 0.1%.

00:14:54.733 --> 00:14:59.494
So this word occurs one word
in a thousand on average.

00:14:59.494 --> 00:15:04.478
And so well if you have a document
size of average length 1000 then we

00:15:04.478 --> 00:15:09.381
kind of gain no blow out really from
going to a positional index because

00:15:09.381 --> 00:15:12.808
there will only be one
position being recorded.

00:15:12.808 --> 00:15:16.142
But if we have documents
that are really long,

00:15:16.142 --> 00:15:22.049
then we might be getting 100 times blow
out in the size of the positional index.

00:15:22.049 --> 00:15:27.529
So everything depends, but just to give
you some very rough rules of thumb for

00:15:27.529 --> 00:15:31.492
what is in some sense typical
documents like web pages,

00:15:31.492 --> 00:15:36.383
that you might expect a positional
index to be somewhere around two to

00:15:36.383 --> 00:15:39.785
four time as large as
a non-positional index.

00:15:39.785 --> 00:15:45.584
And in particular, the size of
a positional index remains smaller than,

00:15:45.584 --> 00:15:50.837
but starts to approach the volume
of the size of the original text.

00:15:50.837 --> 00:15:55.637
So heading toward the third or
half the original size of the text that's

00:15:55.637 --> 00:16:00.597
being indexed, which is much larger
than in the case of a non-positional

00:16:00.597 --> 00:16:04.630
index where it might be down
to something like just 10%.

00:16:04.630 --> 00:16:09.101
So having an IR system doesn't
actually take a lot more space than

00:16:09.101 --> 00:16:11.634
storing the text in the first place.

00:16:15.465 --> 00:16:19.950
I mentioned, when I mentioned biword
indices, that they aren't a useless idea,

00:16:19.950 --> 00:16:23.710
even though they're not normally
the solution by themselves.

00:16:23.710 --> 00:16:25.840
And so let me just come back to that.

00:16:25.840 --> 00:16:29.700
These two approaches can be
very profitably combined.

00:16:29.700 --> 00:16:34.490
So if you look at the query stream of high

00:16:34.490 --> 00:16:38.040
query volume services
like web search engines,

00:16:38.040 --> 00:16:43.860
there tend to be some queries that keep
on turning up again and again and again.

00:16:43.860 --> 00:16:47.030
So things like person
names of popular people.

00:16:47.030 --> 00:16:55.260
Well if we just treat those as just
regular postings list intersection or

00:16:55.260 --> 00:17:00.020
the positional phrase query
posting list intersection,

00:17:00.020 --> 00:17:04.180
what we'd have to do is keep on
doing this intersection over and

00:17:04.180 --> 00:17:08.630
over again, every time that
someone sends that question.

00:17:08.630 --> 00:17:13.510
And it's bad for
cases like Michael Jackson.

00:17:13.510 --> 00:17:18.120
It's less bad when you've got
rare names like Britney Spears,

00:17:18.120 --> 00:17:21.640
because presumably their
posting lists are much shorter,

00:17:21.640 --> 00:17:26.470
and the intersection is roughly the same
as each individual postings list.

00:17:26.470 --> 00:17:31.780
Doing this intersection every time is
especially bad when you have common words,

00:17:31.780 --> 00:17:34.090
like if you're searching for
the band The Who.

00:17:34.090 --> 00:17:36.910
Then what's going to
happen is you're going to

00:17:36.910 --> 00:17:42.000
retrieve two enormous postings lists,
do the intersection of them,

00:17:42.000 --> 00:17:45.980
then end up with a very short postings
list that this phrase queried.

00:17:47.590 --> 00:17:52.140
So in a paper from a group in Melbourne
that's a well known information retrieval

00:17:52.140 --> 00:17:59.280
group in 2004, they investigated a more
sophisticated mixed indexing system.

00:17:59.280 --> 00:18:03.510
So in this, what happened was that for

00:18:03.510 --> 00:18:09.510
common phrases like these examples,
they did build biwords and

00:18:09.510 --> 00:18:16.270
index the biwords, where for rarer phrases
they were done by a positional index.

00:18:16.270 --> 00:18:21.130
And so what they're able to show was
with a typical web query mixture,

00:18:21.130 --> 00:18:26.190
you could execute it in one quarter of
the time of the positional index alone

00:18:26.190 --> 00:18:30.190
by making use of also having
indexed some biwords.

00:18:30.190 --> 00:18:35.570
But at the cost of only taking 26% more
space than having the positional index

00:18:35.570 --> 00:18:36.580
alone.

00:18:36.580 --> 00:18:40.650
So that makes it look
a fairly appealing tradeoff

00:18:40.650 --> 00:18:44.820
to augment the positional
index with common bigrams.

00:18:44.820 --> 00:18:49.030
And while one model of doing
that is to do it as here,

00:18:49.030 --> 00:18:53.340
where you'll work out in
advance the common bigrams and

00:18:53.340 --> 00:18:57.890
then index those in your
standard inverted index.

00:18:57.890 --> 00:19:00.740
In practice what happens
a lot in modern systems is

00:19:00.740 --> 00:19:03.910
that people try to do this
a bit more dynamically, so

00:19:03.910 --> 00:19:08.650
that they keep a cache of commonly
being queried phrase queries.

00:19:08.650 --> 00:19:13.120
And what the result of the postings
list intersection is for each of those.

00:19:13.120 --> 00:19:18.570
And so that's like having added those
biwords to the inverted index but

00:19:18.570 --> 00:19:19.880
done a bit more dynamically.

00:19:22.160 --> 00:19:28.910
Okay, so that's introduced what's
the most useful extension to the classic

00:19:28.910 --> 00:19:34.040
Boolean retrieval model, which is
having support for phrase queries.

00:19:34.040 --> 00:19:36.770
And we introduced a method for
handling those, or

00:19:36.770 --> 00:19:40.360
two methods, but in particular,
we looked at positional indices,

00:19:40.360 --> 00:19:44.410
which can handle phrase queries but also
the proximity queries that we saw earlier.

