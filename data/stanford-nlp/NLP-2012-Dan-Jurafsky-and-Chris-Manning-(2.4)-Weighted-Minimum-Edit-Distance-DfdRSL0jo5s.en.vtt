WEBVTT
Kind: captions
Language: en

00:00:01.018 --> 00:00:03.898
Edit distance can also be weighted.

00:00:03.898 --> 00:00:06.840
Why would we add weights to
the computation of edit distance?

00:00:08.410 --> 00:00:09.870
Think about particular complications.

00:00:09.870 --> 00:00:13.240
In spell correction it's obvious that
some letters are more likely to be

00:00:13.240 --> 00:00:14.970
mistyped than others.

00:00:14.970 --> 00:00:19.050
While in Biology, because of
the constraints of the subject matter

00:00:19.050 --> 00:00:22.480
some kinds of deletions or
insertions are more likely than others.

00:00:22.480 --> 00:00:27.970
So, for example, in spelling, here's
a confusion matrix for spelling errors.

00:00:27.970 --> 00:00:33.380
So, if you'll look at this confusion
matrix you can see that E is a very likely

00:00:33.380 --> 00:00:39.530
to be confused with A or O and
E so vowels tend to be confused.

00:00:41.180 --> 00:00:46.080
But, it's very unlikely to confuse A and
B.

00:00:46.080 --> 00:00:50.470
So A's are confused with E's and
I's and O's and U's and so on.

00:00:50.470 --> 00:00:56.500
So the kind of spelling errors people
make have system masticity to them.

00:00:56.500 --> 00:01:01.220
So, not just confusing vowels with vowels,
but

00:01:01.220 --> 00:01:04.950
also the fact of the keyboard means
that you're likely to make errors

00:01:04.950 --> 00:01:09.870
either using the homologous finger on
the other hand or using nearby keystrokes.

00:01:09.870 --> 00:01:12.750
So the constraints of the domain, in this
case we're talking about spelling or maybe

00:01:12.750 --> 00:01:17.980
we're talking about biology, are going to
make some edits more likely than others.

00:01:21.130 --> 00:01:23.730
So we're going to represent this by
modifying the algorithm slightly

00:01:23.730 --> 00:01:24.840
to add weight.

00:01:24.840 --> 00:01:28.010
So, in the [INAUDIBLE] distance we have
the cost of one for insertion, one for

00:01:28.010 --> 00:01:29.940
deletion, and two for substitution.

00:01:29.940 --> 00:01:32.720
In weighted min edit distance
we simply add a simple

00:01:32.720 --> 00:01:34.780
cost that we look up each time.

00:01:34.780 --> 00:01:37.650
So initialization instead
of just adding one for

00:01:37.650 --> 00:01:40.670
each deletion, we have the actual
cost of each deletion and

00:01:40.670 --> 00:01:43.700
we add up the deletions of each
of the symbols that we delete.

00:01:43.700 --> 00:01:47.150
And instead of having just one for
insertion we have cost for

00:01:47.150 --> 00:01:49.140
each insertion and we add them all up.

00:01:49.140 --> 00:01:50.890
And similarly in the recurrence relation,

00:01:50.890 --> 00:01:55.600
we're going to add a special deletion,
insertion and substitution cost.

00:01:55.600 --> 00:01:57.920
How much is to delete to have
delete that particular character,

00:01:57.920 --> 00:01:59.760
insert that particular character.

00:01:59.760 --> 00:02:02.270
And then we'll end on with
the same termination condition.

00:02:02.270 --> 00:02:05.200
So we'll just add separate little
look up tables that will tell us what

00:02:05.200 --> 00:02:08.660
the deletion, insertion and
substitution cost are for each symbol.

00:02:09.860 --> 00:02:12.440
By the way, where did the name,
dynamic programming, come from?

00:02:14.390 --> 00:02:17.060
Here's some quotes from
Richard Bellman's autobiography.

00:02:17.060 --> 00:02:20.600
Bellman was the one who invented
dynamic programming, and amusingly,

00:02:20.600 --> 00:02:24.420
he tells us that he came up with
the name for dynamic programming

00:02:24.420 --> 00:02:28.420
really as a public relations move to
make an algorithm sound exciting.

00:02:33.680 --> 00:02:37.820
So, this is maybe one of the first
algorithms that was named

00:02:37.820 --> 00:02:42.740
in a branding way to make
an algorithm sound exciting.

00:02:42.740 --> 00:02:46.560
So, there is our algorithm for
weighted minimum at a distance.

