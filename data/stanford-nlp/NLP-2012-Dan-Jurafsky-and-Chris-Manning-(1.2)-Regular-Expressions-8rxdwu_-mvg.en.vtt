WEBVTT
Kind: captions
Language: en

00:00:00.410 --> 00:00:02.610
Now we're going to talk
about text processing.

00:00:02.610 --> 00:00:04.790
The most basic and
fundamental tool we have for

00:00:04.790 --> 00:00:07.530
text processing is the regular expression.

00:00:07.530 --> 00:00:11.450
A regular expression is a formal
language for specifying text strings.

00:00:11.450 --> 00:00:15.250
So let's suppose that we're looking for
woodchucks in a text document.

00:00:16.450 --> 00:00:18.300
Woodchucks can be expressed
in a number of ways.

00:00:18.300 --> 00:00:19.670
We could have a singular woodchuck.

00:00:19.670 --> 00:00:21.600
We could have the plural s at the end.

00:00:21.600 --> 00:00:23.705
We could have a capital
letter at the beginning.

00:00:23.705 --> 00:00:25.640
Or a lowercase, and
any combination of these.

00:00:25.640 --> 00:00:27.810
So we're going to need tools
to deal with this problem.

00:00:29.070 --> 00:00:33.900
So the simplest fundamental tool in
a regular expression is the disjunction.

00:00:33.900 --> 00:00:37.280
The square brackets in a regular
expression pattern mean

00:00:37.280 --> 00:00:39.892
any letter inside these square brackets.

00:00:39.892 --> 00:00:47.350
So, [wW] means either a lowercase w or
a capital W.

00:00:47.350 --> 00:00:50.670
So we can combine that with
oodchuck to match the lowercase or

00:00:50.670 --> 00:00:52.070
uppercase woodchuck.

00:00:52.070 --> 00:00:53.280
And similarly, with digits.

00:00:53.280 --> 00:00:55.440
1, 2, 3, 4 and so on.

00:00:55.440 --> 00:01:00.017
5, 6, 7, 8, 9, 0 matches any digit.

00:01:00.017 --> 00:01:01.940
Now, that was kind of annoying to write.

00:01:01.940 --> 00:01:04.730
So what we'd like to do
instead is have little ranges.

00:01:04.730 --> 00:01:11.590
The range 0 through 9, so [0-9],
means any character inside that range.

00:01:11.590 --> 00:01:18.330
And the range [A-Z] means any character,
any capital letter between A and Z.

00:01:18.330 --> 00:01:21.330
So let's see if we can see how that works.

00:01:21.330 --> 00:01:24.280
So here's an example at our regexpal,
a little tool we're going to use for

00:01:24.280 --> 00:01:26.250
regular expressions searching.

00:01:26.250 --> 00:01:28.720
And we have a little text here from Dr.
Seuss.

00:01:28.720 --> 00:01:31.000
We looked!
Then we saw him step in on the mat.

00:01:31.000 --> 00:01:32.300
We looked!
And we saw him!

00:01:32.300 --> 00:01:35.025
The Cat in the Hat!

00:01:35.025 --> 00:01:38.230
And let's try our disjunctions.

00:01:38.230 --> 00:01:43.216
So, we can have the capital W and
the lowercase w.

00:01:43.216 --> 00:01:46.820
And, excuse me,
a capital W and a lowercase w.

00:01:46.820 --> 00:01:49.340
And that's going to match, as you can see.

00:01:49.340 --> 00:01:53.287
The capital W's and
the lowercase w's just fine.

00:01:55.224 --> 00:02:00.600
Or we could have all the e's and
all the m's.

00:02:00.600 --> 00:02:03.210
And that's going to match all the e's and
the m's.

00:02:03.210 --> 00:02:05.754
Or in our ranges,
we can have all the capital letters.

00:02:07.278 --> 00:02:09.290
There's all the capital
letters being matched.

00:02:09.290 --> 00:02:10.987
We can have all the lower case letters.

00:02:12.865 --> 00:02:14.520
There's a lot of lower case letters there.

00:02:14.520 --> 00:02:16.700
Or we could match all of
the alphanumeric characters.

00:02:16.700 --> 00:02:20.450
Think for a second how to match all
the alphanumeric characters we can have.

00:02:23.744 --> 00:02:26.660
Or we could simply match some of
the non-alphanumeric characters.

00:02:26.660 --> 00:02:31.150
We could have space and exclamation
point in our square brackets, and

00:02:31.150 --> 00:02:35.271
that's going to match as you can see
some of the non-alphabetic characters.

00:02:35.271 --> 00:02:36.640
Okay.
So let's go on.

00:02:36.640 --> 00:02:40.030
Another kind of thing we might want to do
in our regular expressions is negation in

00:02:40.030 --> 00:02:40.800
our disjunction.

00:02:40.800 --> 00:02:46.110
We might want to say we don't
want some kind of set of letters.

00:02:46.110 --> 00:02:50.390
So for example, we might want to say,
not a capital letter.

00:02:50.390 --> 00:02:54.387
We can do that by saying, [^A-Z].

00:02:54.387 --> 00:02:57.340
Caret, when it occurs right after
the square brackets, it means not.

00:02:57.340 --> 00:03:00.565
[^A-Z], not a capital letter.

00:03:00.565 --> 00:03:07.222
[^Aa] means neither a capital A,
nor a little a.

00:03:07.222 --> 00:03:15.185
And [^e^] means not an e and not a caret.

00:03:15.185 --> 00:03:19.059
So, you can see that the caret when it
occurs right after the square bracket

00:03:19.059 --> 00:03:22.470
means not, but
later on means simply just a caret.

00:03:22.470 --> 00:03:23.664
So, lets take a look at that.

00:03:28.293 --> 00:03:33.880
So we can try finding all
of the non-capital letters.

00:03:38.625 --> 00:03:40.530
Here's all the non-capital letters.

00:03:40.530 --> 00:03:42.552
How about all the non exclamation points?

00:03:44.232 --> 00:03:48.378
Most things.
And the non-alphanumerics, sorry,

00:03:48.378 --> 00:03:50.747
the non-alphabetics.

00:03:50.747 --> 00:03:54.740
There's just the spaces and
exclamation points, as you can see.

00:03:56.020 --> 00:03:57.920
How about looking for a caret.

00:03:57.920 --> 00:04:00.040
Any carets in here, there are none.

00:04:00.040 --> 00:04:02.070
So there are no carets in here,
so nothing matches.

00:04:04.080 --> 00:04:08.060
Another kind of disjunction which can
be used for longer strings is the pipe

00:04:08.060 --> 00:04:13.511
symbol, sometimes called or,
or pipe, or just disjunction.

00:04:13.511 --> 00:04:17.850
So groundhog|woodchuck will mean

00:04:17.850 --> 00:04:22.070
either the string groundhog or
the string woodchuck.

00:04:22.070 --> 00:04:25.600
So we can use the pipe symbol sometimes
for the same thing as the square brackets.

00:04:25.600 --> 00:04:29.723
So a|b|c is the same as [abc].

00:04:29.723 --> 00:04:34.120
And we can combine these things.

00:04:34.120 --> 00:04:37.920
We can combine the square brackets and the
pipe so we can have groundhog or woodchuck

00:04:37.920 --> 00:04:41.010
but use our square brackets for expressing
capitalization at the beginning.

00:04:44.330 --> 00:04:45.990
And we can see that in our little example.

00:04:45.990 --> 00:04:51.014
We can have looked|step, and
sure enough there the words looked and

00:04:51.014 --> 00:04:56.935
step are both highlighted, or we can
have disjunction of just random things.

00:04:56.935 --> 00:04:57.750
They don't have to be words.

00:04:57.750 --> 00:05:02.710
We can have all of the at's and

00:05:02.710 --> 00:05:07.650
all of the ook's and all of the ook's,
and any random string is fine.

00:05:07.650 --> 00:05:11.170
Finally, there's sets of special
characters that are very important in

00:05:11.170 --> 00:05:12.631
regular expressions.

00:05:12.631 --> 00:05:17.190
The question mark means that
the previous character is optional.

00:05:17.190 --> 00:05:21.760
So the question mark after this u here,
will match the word color with or

00:05:21.760 --> 00:05:23.230
without the u.

00:05:23.230 --> 00:05:24.570
Without the u, with the u.

00:05:26.090 --> 00:05:29.370
Then there are the two Kleene
operators named for Stephen Kleene.

00:05:30.460 --> 00:05:35.821
Kleene star matches zero or more of the
previous characters, so here's the star,

00:05:35.821 --> 00:05:41.045
it matches zero or more o's, so we have
one o followed by zero or more other o's.

00:05:41.045 --> 00:05:45.954
So there's the initial o and
zero other o's and then our h!.

00:05:45.954 --> 00:05:51.160
Here's our initial o followed by one o and
then the h and so on.

00:05:51.160 --> 00:05:53.210
Two, three, and so on.

00:05:53.210 --> 00:05:57.140
Sometimes more simple,
we can have the Kleene plus.

00:05:57.140 --> 00:05:59.250
So that means one or
more of the previous characters.

00:05:59.250 --> 00:06:02.900
So there's our o followed by the plus,
meaning one or more o.

00:06:04.060 --> 00:06:05.250
So there's one o.

00:06:05.250 --> 00:06:08.630
There's two o's, three o's, and so on.

00:06:08.630 --> 00:06:11.520
And the dot is a special character,
meaning any character.

00:06:11.520 --> 00:06:16.590
So beg.n can match begin, begun, beg3n.

00:06:16.590 --> 00:06:18.224
It matches anything.

00:06:20.973 --> 00:06:23.060
And finally two special characters.

00:06:24.560 --> 00:06:27.970
The caret matches
the beginning of the line.

00:06:27.970 --> 00:06:32.320
So, ^ [A-Z] matches a capital letter
at the beginning of the line.

00:06:32.320 --> 00:06:34.970
The dollar sign matches the end of a line.

00:06:34.970 --> 00:06:37.550
So, [A-Z]$ matches the end of a line.

00:06:37.550 --> 00:06:39.670
Like a capital letter
at the end of a line.

00:06:39.670 --> 00:06:41.400
And then,
if we want to talk about a period,

00:06:41.400 --> 00:06:45.720
since periods are a special character,
we have to escape them.

00:06:45.720 --> 00:06:47.660
And backslash period means a period.

00:06:47.660 --> 00:06:49.681
So a period by itself means any character.

00:06:49.681 --> 00:06:53.675
Backslash period, means a real period.

00:06:53.675 --> 00:06:55.240
Let's go look at some of these.

00:06:57.434 --> 00:07:04.880
So, here's the letter o, here's zero or,
let's make it one or more o first.

00:07:04.880 --> 00:07:06.100
Here's one or more o.

00:07:07.580 --> 00:07:12.133
So there's one o over here and
two o's over here.

00:07:17.953 --> 00:07:22.640
And now let's look at beginnings and
ends of lines.

00:07:22.640 --> 00:07:26.680
Here is, capital letters
at the beginning of a line.

00:07:28.490 --> 00:07:33.070
Here's capital letters
at the end of a line.

00:07:35.310 --> 00:07:35.890
There aren't any.

00:07:37.500 --> 00:07:39.190
Here's punctuation at the end of a line.

00:07:40.282 --> 00:07:41.960
There's only exclamation
points at the end of the line.

00:07:44.190 --> 00:07:48.660
Here's all the periods, remember we
have to backslash our periods, and

00:07:48.660 --> 00:07:53.030
if we didn't backslash the period
we would get all the characters.

00:07:53.030 --> 00:07:54.852
because period matches everything.

00:07:57.928 --> 00:07:59.790
All right, let's do one more example.

00:07:59.790 --> 00:08:03.050
Let's look at this little sentence here.

00:08:03.050 --> 00:08:05.020
The other one there, the blithe one.

00:08:06.640 --> 00:08:09.110
Let's walk through how to search for
words.

00:08:09.110 --> 00:08:12.260
Let's find all the word the in
this little passage, so think for

00:08:12.260 --> 00:08:13.805
yourself how you would do this.

00:08:13.805 --> 00:08:16.840
Well the simplest thing you might do,
is just type the t, h, e.

00:08:18.340 --> 00:08:21.970
And that does a good job
of finding this the here.

00:08:21.970 --> 00:08:24.730
And it finds this the, and that the.

00:08:24.730 --> 00:08:26.870
But, it misses these two the's.

00:08:26.870 --> 00:08:28.260
It also finds some other things.

00:08:28.260 --> 00:08:29.220
Let's fix the first problem.

00:08:30.270 --> 00:08:35.142
How do we not only get the the's in
the middle, but those capitalized

00:08:35.142 --> 00:08:40.106
The's at the beginning, what we're
going to use are our disjunction.

00:08:44.363 --> 00:08:51.210
And sure enough, that correctly now
matches the two beginning of line The's.

00:08:51.210 --> 00:08:53.540
But you notice that our pattern,

00:08:53.540 --> 00:08:56.410
although it now captures
something it missed before,

00:08:56.410 --> 00:09:01.820
it still captures things that shouldn't
be captured, other, there, and blithe.

00:09:01.820 --> 00:09:05.410
So we need to augment our pattern, so
how are we going to augment our pattern?

00:09:05.410 --> 00:09:09.090
We really want the when there's not
an alphabetic character around it,

00:09:09.090 --> 00:09:11.990
we need a space or a punctuation or
something non-alphabetic.

00:09:11.990 --> 00:09:17.670
So let's just say non-alphabetic
afterwards, great.

00:09:17.670 --> 00:09:21.260
That gets rid of other and
there, it doesn't solve blithe,

00:09:21.260 --> 00:09:23.720
because blithe has an alphabetic
character before it.

00:09:23.720 --> 00:09:30.605
So let's go fix blithe by saying
non-alphabetic before it.

00:09:30.605 --> 00:09:32.030
There we go.

00:09:32.030 --> 00:09:35.150
Now we found all of our the's.

00:09:36.600 --> 00:09:42.080
So we looked for the,
we noticed that miscapitalized examples,

00:09:42.080 --> 00:09:47.110
so we added some,
we made our pattern more expansive.

00:09:47.110 --> 00:09:52.910
We've increased the yield of our pattern,
but that incorrectly returns more things.

00:09:52.910 --> 00:09:58.450
So then, we need to make the pattern
more precise by specifying more things.

00:09:58.450 --> 00:10:04.380
This process that we went through is
based on fixing two kinds of errors.

00:10:04.380 --> 00:10:06.900
One is matching strings we
shouldn't have matched.

00:10:06.900 --> 00:10:10.290
We matched there, we matched other.

00:10:10.290 --> 00:10:12.890
That's solving the problem
of false positives, or

00:10:12.890 --> 00:10:14.160
they're called Type I errors.

00:10:14.160 --> 00:10:16.660
We are matching things we shouldn't match.

00:10:16.660 --> 00:10:20.980
And the other thing we went through is to
solve the problem of not matching things

00:10:20.980 --> 00:10:21.600
we should have matched.

00:10:21.600 --> 00:10:23.553
So we missed those capital The's.

00:10:23.553 --> 00:10:27.030
And that's dealing with the problem
of false negatives or Type II errors.

00:10:27.030 --> 00:10:29.575
And it turns out in natural
language processing,

00:10:29.575 --> 00:10:33.510
we're constantly dealing with
these two classes of errors.

00:10:33.510 --> 00:10:35.340
So reducing the error rate
in any application, and

00:10:35.340 --> 00:10:36.240
we're going to see this again and

00:10:36.240 --> 00:10:40.230
again in this course,
involves two antagonistic efforts.

00:10:40.230 --> 00:10:41.800
We're increasing the accuracy or

00:10:41.800 --> 00:10:45.060
precision, which helps us
minimize those false positives.

00:10:45.060 --> 00:10:46.880
Or we're increasing our coverage, or

00:10:46.880 --> 00:10:49.800
technically called recall,
minimizing our false negatives.

00:10:51.350 --> 00:10:52.280
So in summary,

00:10:52.280 --> 00:10:57.890
regular expressions play a surprisingly
large role in text processing.

00:10:57.890 --> 00:11:01.920
And the sophisticated sequences of regular
expressions that we've seen very simple

00:11:01.920 --> 00:11:06.830
versions of, are often the first model for
almost any text processing task.

00:11:06.830 --> 00:11:09.887
For harder tasks, we're often going to
be using, and we'll introduce these,

00:11:09.887 --> 00:11:12.495
these machine learning classifiers
that are much more powerful.

00:11:12.495 --> 00:11:15.977
But it turns out even then regular
expressions are used as features in

00:11:15.977 --> 00:11:19.590
the classifiers, and are very useful
in capturing generalizations.

00:11:20.660 --> 00:11:24.350
So you're going to be returning again and
again to regular expressions.

