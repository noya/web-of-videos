WEBVTT
Kind: captions
Language: en

00:00:01.587 --> 00:00:06.167
In research NLP these days, there's always
a lot of talk of probabilistic models and

00:00:06.167 --> 00:00:07.610
machine learning.

00:00:07.610 --> 00:00:10.730
But if you actually look at
large systems under the hood,

00:00:10.730 --> 00:00:15.010
what you'll almost always find is that
they also make quite a bit of use

00:00:15.010 --> 00:00:18.060
of regular expressions in various places.

00:00:18.060 --> 00:00:19.100
And for many tasks,

00:00:19.100 --> 00:00:23.700
it turns out that regular expressions
are just a very practical and

00:00:23.700 --> 00:00:28.560
capable way of specifying various
kinds of natural language patterns.

00:00:28.560 --> 00:00:32.848
I'm going to show you one example of this
now, by showing you how we use regular

00:00:32.848 --> 00:00:37.136
expressions for the English Tokenizer
inside the Stanford NLP tools such as

00:00:37.136 --> 00:00:41.772
the Power Zone, Part-Of-Speech Tagger,
or for the coreNLP Suite, overall.

00:00:43.170 --> 00:00:46.780
Okay, here we are with the code for
the Stanford English Tokenizer.

00:00:46.780 --> 00:00:54.630
So what it is, is it's a large
deterministic regular expression.

00:00:54.630 --> 00:00:58.190
And so, what it's written in
is with a tool called JFlex.

00:00:58.190 --> 00:01:01.540
So, JFlex belongs to a family of,

00:01:01.540 --> 00:01:04.590
what are commonly called in
computer science, lexers.

00:01:04.590 --> 00:01:09.800
Which is just another word for tokenizers,
which take a sequence of characters and

00:01:09.800 --> 00:01:12.450
cut pieces,
one token at a time off the front of it.

00:01:12.450 --> 00:01:15.300
So there was the original
Lex part of Unix, and

00:01:15.300 --> 00:01:20.790
then Flex, and this is JFlex which
is a java-compatible version.

00:01:20.790 --> 00:01:24.627
Let's scroll down to where some of
the regular expressions are used to define

00:01:24.627 --> 00:01:25.699
character classes.

00:01:29.438 --> 00:01:33.653
Often, what you find is that many of the
regular expressions aren't actually very

00:01:33.653 --> 00:01:37.869
complicated, that they're really nothing
more than lists that have been put into

00:01:37.869 --> 00:01:41.730
regular expressions by putting vertical
bars in between for automation.

00:01:41.730 --> 00:01:46.160
And so for example,
we see that in several places here.

00:01:46.160 --> 00:01:49.910
So here, we have one for
abbreviated months.

00:01:49.910 --> 00:01:53.490
And here, we have one for
abbreviated days of the week.

00:01:53.490 --> 00:01:57.535
And that continues on for some of these
other ones like, American states and

00:01:57.535 --> 00:02:02.535
various other kinds of person name,
title acronyms, down here.

00:02:02.535 --> 00:02:05.564
But, let's go on a little bit
further to one that's a bit more

00:02:05.564 --> 00:02:06.797
interesting than that.

00:02:14.274 --> 00:02:18.900
Okay, so here's one for phone numbers.

00:02:18.900 --> 00:02:21.990
This is the kind of ill-documented
regular expression that's a little

00:02:21.990 --> 00:02:26.100
bit hard to actually get your head
around but are much used in practice.

00:02:26.100 --> 00:02:29.488
So at the very top level
of this regular expression,

00:02:29.488 --> 00:02:32.955
things are divided up by
this automation right here.

00:02:32.955 --> 00:02:37.741
And on the right-hand side of
the automation there's a pattern

00:02:37.741 --> 00:02:41.330
where the separator is being used as dots.

00:02:41.330 --> 00:02:45.180
And so, that one's separated
out as consistent use of dots,

00:02:45.180 --> 00:02:48.600
because otherwise it's easy for the
regular expression to get it wrong, and

00:02:48.600 --> 00:02:53.090
also recognize various kinds of
decimal numbers, and other patters.

00:02:53.090 --> 00:02:56.080
And so, that part of it is
actually the easier part.

00:02:56.080 --> 00:03:00.900
So, we can have at the beginning
option way, the use of plus signs.

00:03:00.900 --> 00:03:02.680
Which are used in Europe and

00:03:02.680 --> 00:03:07.580
most of the rest of the world, as the
international prefix for country codes.

00:03:07.580 --> 00:03:10.870
And then,
we can have the country code here,

00:03:10.870 --> 00:03:16.540
which is just numbers of the range 2 to 4,
and then all of that is optional.

00:03:17.910 --> 00:03:24.800
And then, after that we've got a first set
of numbers which can be the area code.

00:03:24.800 --> 00:03:28.450
The dot, then the second set of numbers,

00:03:28.450 --> 00:03:30.810
which I guess historically
was the exchange.

00:03:30.810 --> 00:03:33.440
And then finally,
the third set of numbers.

00:03:33.440 --> 00:03:36.860
And so, these sets of numbers
are then being given a length.

00:03:36.860 --> 00:03:39.640
So this has to be between 3 and 4 numbers.

00:03:39.640 --> 00:03:42.130
This has to be 3 and 5 numbers.

00:03:42.130 --> 00:03:45.460
And the area code has to be 2 and
4 numbers, and so,

00:03:45.460 --> 00:03:47.980
those ranges are chosen so
that they'll work

00:03:47.980 --> 00:03:51.620
with the phone numbers of a bunch
of the countries around the world.

00:03:51.620 --> 00:03:55.280
But if you know, well, your international
phone numbers, you'll realize there

00:03:55.280 --> 00:04:00.710
are actually some cases that won't
still be recognized by those.

00:04:00.710 --> 00:04:05.127
So what then, if we go to the left-hand
side of the regular expression?

00:04:05.127 --> 00:04:10.328
It's effectively doing the same thing but
is more complex.

00:04:10.328 --> 00:04:12.865
So, that the first part of it is,

00:04:12.865 --> 00:04:17.863
again, going to recognize things
like optional country codes.

00:04:17.863 --> 00:04:20.480
So, you can see the same piece over here.

00:04:23.090 --> 00:04:25.460
And the optional country code.

00:04:25.460 --> 00:04:27.360
But it's allowing in
some other possibilities.

00:04:27.360 --> 00:04:30.421
So here we've escaped the parentheses, so

00:04:30.421 --> 00:04:35.892
you can actually sort of have some numbers
that are put inside of parentheses.

00:04:35.892 --> 00:04:40.353
And further on, we've got this
character class where we're allowing

00:04:40.353 --> 00:04:43.820
a variety of other separators
apart from period.

00:04:43.820 --> 00:04:48.950
So, we can have a dash,
which again, needs to be escaped.

00:04:48.950 --> 00:04:53.090
There can just be a space, or
there can be a non-breaking space.

00:04:53.090 --> 00:04:56.680
So, here's a Unicode escape for
non-breaking space.

00:04:56.680 --> 00:04:57.720
And so, then overall,

00:04:57.720 --> 00:05:01.830
this will allow it to recognize
a bunch of formats for phone numbers.

00:05:01.830 --> 00:05:04.990
So, it'll recognize almost all
American phone numbers and

00:05:04.990 --> 00:05:09.540
generate us pretty well with things
like UK and Australian phone numbers.

00:05:09.540 --> 00:05:13.080
If you want an example of where it doesn't
work, the normal phone number format

00:05:13.080 --> 00:05:17.590
in France is you just have pairs of
digits with spaces in between them,

00:05:17.590 --> 00:05:19.690
and that's not included here.

00:05:19.690 --> 00:05:23.830
And the difficulty isn't writing
a regular expression that matches that,

00:05:23.830 --> 00:05:28.590
it's in this context of deterministic
regular expression matcher.

00:05:28.590 --> 00:05:33.451
Or, managing to write one which won't also
wrongly match various other things such as

00:05:33.451 --> 00:05:36.913
numbers that are just appearing
as a sequence of numbers, for

00:05:36.913 --> 00:05:38.060
some other reason.

00:05:39.976 --> 00:05:44.381
Well, I hope that's given you some idea
of the use of regular expressions in NLP

00:05:44.381 --> 00:05:45.230
systems.

00:05:45.230 --> 00:05:47.780
If you poke around in other NLP systems,

00:05:47.780 --> 00:05:50.190
I'm sure you'll find
lots of other examples.

00:05:50.190 --> 00:05:54.090
Commonly, when people want to match
particular patterns, whether they

00:05:54.090 --> 00:05:58.390
be patterns at the level of words or
patterns at the level of parts of speech.

00:05:58.390 --> 00:06:00.530
They can just be very convenient and

00:06:00.530 --> 00:06:04.650
practical methods to solve
many practical tasks.

