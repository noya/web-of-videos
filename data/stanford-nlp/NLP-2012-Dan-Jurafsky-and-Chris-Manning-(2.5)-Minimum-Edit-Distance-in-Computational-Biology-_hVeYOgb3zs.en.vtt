WEBVTT
Kind: captions
Language: en

00:00:01.006 --> 00:00:05.611
There are a number of advanced variants of
minimum edit distance that play a special

00:00:05.611 --> 00:00:07.463
role in computational biology.

00:00:07.463 --> 00:00:10.437
So recall that in computational biology,

00:00:10.437 --> 00:00:15.642
what we're aligning is sequences of
nucleotides or sometimes proteins,

00:00:15.642 --> 00:00:21.110
and our job is to take two strings like
this and produce an alignment like this.

00:00:23.920 --> 00:00:28.997
So in biology, this is important for
a number of reasons.

00:00:28.997 --> 00:00:33.589
We can be finding regions in the genome.

00:00:33.589 --> 00:00:35.860
We could be discovering
functions of genes.

00:00:35.860 --> 00:00:39.340
We could be looking for evolutionary
things by comparing different species.

00:00:39.340 --> 00:00:44.303
This is also important for
assembling fragments of DNA sequencing.

00:00:44.303 --> 00:00:48.089
We're going to be trying to assemble
fragments and we want to look for

00:00:48.089 --> 00:00:49.381
overlapping pieces.

00:00:49.381 --> 00:00:52.883
We'll talk about overlapping pieces and
find some matches between them.

00:00:52.883 --> 00:00:57.569
Find that these two pieces match and we're
comparing individuals, and looking for

00:00:57.569 --> 00:00:58.298
mutations.

00:00:58.298 --> 00:01:02.033
Finding places where there
are similarities and differences.

00:01:02.033 --> 00:01:06.747
In general, in natural language
processing, we talk about distance.

00:01:06.747 --> 00:01:09.524
A string at a distance,
a minimum at a distance.

00:01:09.524 --> 00:01:15.523
So we're minimizing distance and
we're computing weights for things.

00:01:15.523 --> 00:01:20.283
In computational biology,
we're talking about similarities.

00:01:20.283 --> 00:01:21.810
So, we are maximizing similarities.

00:01:21.810 --> 00:01:24.164
So, we are asking how
similar two things are.

00:01:24.164 --> 00:01:26.278
So, we're trying to maximize something and

00:01:26.278 --> 00:01:28.785
we generally talk about
scores rather than weights.

00:01:28.785 --> 00:01:33.149
So in computational biology,
the standard minimum at a distance

00:01:33.149 --> 00:01:37.766
algorithm that we've just looked
at is called Needleman-Wunsch.

00:01:37.766 --> 00:01:45.205
And I've shown you the algorithm here, but
it's the same thing that we saw before.

00:01:45.205 --> 00:01:51.122
Although in general, we'll use d to mean
the cost of insertions and deletions.

00:01:51.122 --> 00:01:54.539
And we'll have a little s value for
the substitution,

00:01:54.539 --> 00:01:58.113
the positive or
negative value of substituting things.

00:01:58.113 --> 00:02:02.245
And in general in biology, we'll talk
about positive cost for things that match.

00:02:02.245 --> 00:02:09.265
Positive value for things that match and
a cost for deletions, and insertions.

00:02:11.115 --> 00:02:14.333
So, here's the Needleman-Wunsch matrix.

00:02:14.333 --> 00:02:18.357
And notice that as opposed to what we did
in natural language processing in general

00:02:18.357 --> 00:02:21.584
and computational biology,
we put the origin at the upper left.

00:02:28.485 --> 00:02:33.072
So, lets first look at some variants that
are important in computational biology.

00:02:33.072 --> 00:02:38.115
So, one is cases where it's possible to
have unlimited gaps at the beginning and

00:02:38.115 --> 00:02:39.161
end of a string.

00:02:39.161 --> 00:02:42.854
And this happens exactly when we
have two little snips of DNA and

00:02:42.854 --> 00:02:47.313
we know that the endpoints of one might
overlap with the ends of another, but

00:02:47.313 --> 00:02:50.604
there might be something else
going on in other places.

00:02:50.604 --> 00:02:54.519
So here's one long sequence and
here's another long sequence, but

00:02:54.519 --> 00:02:59.120
it's just this piece of this sequence and
this piece of this that might overlap.

00:02:59.120 --> 00:03:02.859
So, we don't want to penalize the fact
that there's other things going

00:03:02.859 --> 00:03:05.050
on before here or after here.

00:03:05.050 --> 00:03:08.220
So we'd like to modify the algorithm,
so it doesn't penalize gaps at the end.

00:03:10.380 --> 00:03:13.260
And in fact, there can be various
different kinds of overlapping of

00:03:13.260 --> 00:03:15.100
this sort.

00:03:15.100 --> 00:03:19.600
This might happen when we're doing
sequencing and we have overlapping reads

00:03:20.660 --> 00:03:25.280
or it might be that we're looking for
a piece of a gene inside another piece.

00:03:25.280 --> 00:03:29.200
And so, we have a subset
piece inside a larger piece.

00:03:31.390 --> 00:03:36.918
So the variant of the dynamic
programming algorithm that we use for

00:03:36.918 --> 00:03:44.240
the overlap detection variant, we'll just
make a few small changes in the algorithm.

00:03:44.240 --> 00:03:49.197
So first,
we just change the initialization, so

00:03:49.197 --> 00:03:55.451
that it doesn't cost us anything
to start from a long string and

00:03:55.451 --> 00:03:59.714
delete everything or insert everything.

00:03:59.714 --> 00:04:04.985
So it used to be that we had -i*d here and

00:04:04.985 --> 00:04:07.628
we had -j*d here.

00:04:07.628 --> 00:04:12.831
And we've gotten rid of those,
because allowing ourselves

00:04:12.831 --> 00:04:18.657
to start at a path at a random point
way out here in the intersection.

00:04:18.657 --> 00:04:23.529
So, we're allowing ourselves
to start at zero cost here and

00:04:23.529 --> 00:04:28.794
not be penalized for not matching
all these things up until here.

00:04:28.794 --> 00:04:35.636
So we're looking for,
again, an edge overlaps.

00:04:35.636 --> 00:04:38.528
And now for our termination condition,

00:04:38.528 --> 00:04:42.608
we're going to start from not
from the upper right corner,

00:04:42.608 --> 00:04:47.216
because we're allowing a match not
to go all the way to the edge.

00:04:47.216 --> 00:04:50.996
But we'll find the place
along the final column or

00:04:50.996 --> 00:04:57.890
the final row where we have the maximum
value and we'll trace back from there.

00:04:57.890 --> 00:05:01.454
So in this case, our maximum value
is here in this last column and

00:05:01.454 --> 00:05:03.178
we'll trace back from there.

00:05:07.361 --> 00:05:11.356
A similar extension of the
Needleman-Wunsch or the standard dynamic

00:05:11.356 --> 00:05:15.974
programming algorithm for string at
a distance is the local alignment problem.

00:05:15.974 --> 00:05:17.998
So, here's the local alignment problem.

00:05:17.998 --> 00:05:24.656
We have two strings X of length M and

00:05:24.656 --> 00:05:30.030
Y and length N and we want to find two
substrings, whose similarity is maximum.

00:05:30.030 --> 00:05:33.230
So, image that here's x and here's y.

00:05:33.230 --> 00:05:41.056
We'd like to out of these two strings we'd
like to find these two substrings, cccggg.

00:05:41.056 --> 00:05:43.495
That's the largest similar substring.

00:05:47.518 --> 00:05:52.418
So it's very similar to the overlap
detection variant we saw

00:05:52.418 --> 00:05:57.414
except not only do we allow
ourselves not to ignore previously

00:05:57.414 --> 00:06:02.908
unaligned sequences at the beginning and
end, but also anywhere.

00:06:02.908 --> 00:06:07.868
So, we can basically have our maximum
alignment be somewhere in the middle

00:06:07.868 --> 00:06:08.824
as it is here.

00:06:14.165 --> 00:06:19.394
So in order to modify the Needleman-Wunsch
algorithm to allow any kind

00:06:19.394 --> 00:06:25.681
of local alignments, the new version is
now called the Smith-Waterman algorithm.

00:06:25.681 --> 00:06:29.786
And we're first,
going to allow as we did for

00:06:29.786 --> 00:06:35.263
the overlap detection variant
allow the initialization

00:06:35.263 --> 00:06:38.927
conditions to be zero both for x and y.

00:06:38.927 --> 00:06:42.323
So, we don't penalize ourselves for
initial strings.

00:06:42.323 --> 00:06:47.279
And now we're going to make one more
modification, which is that in each cell,

00:06:47.279 --> 00:06:51.169
when we're looking at the possible
places that we could come

00:06:51.169 --> 00:06:53.170
from to choose the alignment.

00:06:53.170 --> 00:06:57.927
We're not going to only pick the maximum
of the three previous cells,

00:06:57.927 --> 00:07:01.028
but we're also going to
add a maximum of zero.

00:07:01.028 --> 00:07:06.254
So we're going to let ourselves in
biology, we're talking about maximizing

00:07:06.254 --> 00:07:11.570
similarity when things get very different
and we have a very negative score.

00:07:11.570 --> 00:07:14.180
We're just going to start
all over again from zero.

00:07:14.180 --> 00:07:17.707
Allow myself to just throw away
regions that don't align at all.

00:07:22.712 --> 00:07:26.289
The termination condition of
the Smith-Waterman algorithm depends on

00:07:26.289 --> 00:07:27.582
what we're looking for.

00:07:27.582 --> 00:07:32.092
If we just want the best local alignment,
we'll pick the place that's

00:07:32.092 --> 00:07:36.010
maximum in the entire array and
we'll trace back from there.

00:07:37.890 --> 00:07:42.648
If we want all the local alignments that
score greater than some threshold t,

00:07:42.648 --> 00:07:46.247
then maybe we'll find some
place that's greater than t.

00:07:46.247 --> 00:07:48.863
Find all those places and
trace back all of them.

00:07:48.863 --> 00:07:52.629
Now, this gets complicated by the fact
that there can be overlapping local

00:07:52.629 --> 00:07:53.357
alignments.

00:07:53.357 --> 00:07:56.785
So here,
we might have two alignments like this and

00:07:56.785 --> 00:08:00.382
it might be that they actually
overlap tracing back.

00:08:00.382 --> 00:08:02.073
So, there can be some complications here.

00:08:02.073 --> 00:08:04.498
But if you want the best local alignment,
that's actually much easier.

00:08:07.650 --> 00:08:09.478
So, here's an example of local alignment.

00:08:09.478 --> 00:08:14.718
So let's imagine that we're getting one
positive point every time two symbols

00:08:14.718 --> 00:08:19.658
match and a negative point for
any deletion, insertion or substitution.

00:08:19.658 --> 00:08:25.322
And then let's look for
all the local alignments

00:08:25.322 --> 00:08:30.858
between these two strings,
ATCAT and ATTATC.

00:08:30.858 --> 00:08:37.942
If we fill in the matrix, again,
we start with zero's everywhere,

00:08:37.942 --> 00:08:42.106
because we're doing local alignment.

00:08:42.106 --> 00:08:47.101
If we then look for regions, cells that
have a maximum distance to trace back

00:08:47.101 --> 00:08:49.299
from, we see two of these cells.

00:08:55.347 --> 00:09:02.169
So one of them corresponds to
the alignment, ATCAT to ATTAT.

00:09:02.169 --> 00:09:06.460
So we have four stings that match,
one mismatch, so

00:09:06.460 --> 00:09:09.199
that going to be distance of three.

00:09:09.199 --> 00:09:15.011
And the other one of them over here,
corresponds to the alignment

00:09:15.011 --> 00:09:20.198
between ATC and
ATC where we have three matching symbols.

00:09:23.668 --> 00:09:26.670
So, those are some of the more advanced
variants of edit distance that we

00:09:26.670 --> 00:09:28.010
see in computational biology.

