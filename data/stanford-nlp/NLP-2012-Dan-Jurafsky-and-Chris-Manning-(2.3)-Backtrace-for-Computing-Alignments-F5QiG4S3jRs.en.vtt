WEBVTT
Kind: captions
Language: en

00:00:01.730 --> 00:00:04.840
Knowing the edit distance between
two strings is important, but

00:00:04.840 --> 00:00:07.070
it turns out not to be sufficient.

00:00:07.070 --> 00:00:10.500
We often need something more, which
is the alignment between two strings.

00:00:10.500 --> 00:00:13.120
We want to know which
symbol in the string x

00:00:13.120 --> 00:00:15.240
corresponds to which
symbol in the string y.

00:00:15.240 --> 00:00:16.600
And this is going to be important.

00:00:16.600 --> 00:00:20.570
for any application we have a beta
distance, often from spell checking

00:00:20.570 --> 00:00:23.400
to machine translation,
even in computational biology.

00:00:23.400 --> 00:00:27.370
And the way we compute this
alignment is we keep a backtrace.

00:00:27.370 --> 00:00:31.270
A backtrace is simply a pointer where we
enter each cell in the matrix that tells

00:00:31.270 --> 00:00:32.850
us where we came from.

00:00:32.850 --> 00:00:37.220
And when we reach the end, the upper right
corner of our matrix, we can use that

00:00:37.220 --> 00:00:40.690
pointer and then trace back through all of
the pointers to read off the alignment.

00:00:43.340 --> 00:00:45.140
Let's see how this works in practice.

00:00:45.140 --> 00:00:50.200
Again, I've given you the equation for
each cell in edit distance.

00:00:50.200 --> 00:00:53.660
And if we put in some of our
values that we saw earlier,

00:00:53.660 --> 00:00:55.277
I'll start by putting in some values.

00:00:55.277 --> 00:01:03.850
So all right,

00:01:03.850 --> 00:01:08.280
so we can ask how did we
get to this value two.

00:01:09.910 --> 00:01:14.390
Two is, we picked a minimum of three
values we could either take, so

00:01:14.390 --> 00:01:18.400
two is the distance this two here is
the difference between the string i.

00:01:18.400 --> 00:01:23.540
And the string e and we got that by
saying, it's either the alignment

00:01:23.540 --> 00:01:27.780
between nothing and
e plus the insertion of an extra i.

00:01:29.500 --> 00:01:34.910
So that's distance of
one plus one is two Or

00:01:34.910 --> 00:01:38.550
0 plus 2 is 2, or 1 plus 1 is 2.

00:01:38.550 --> 00:01:40.750
So we have three different values.

00:01:40.750 --> 00:01:44.320
So if we were asking which minimum
path did we come from, really,

00:01:44.320 --> 00:01:45.120
they're all the same.

00:01:45.120 --> 00:01:46.100
We could have come from any of them.

00:01:46.100 --> 00:01:49.890
And that's going to be true for
this value of 3, as well.

00:01:49.890 --> 00:01:53.110
We computed it as the minimum of 2 plus 1,
1 plus 2, or 2 plus 1.

00:01:53.110 --> 00:01:57.240
So it's going to come from here,
here, or here.

00:01:57.240 --> 00:01:58.870
And similarly, that's going to be true.

00:01:58.870 --> 00:02:02.050
I didn't work out the arithmetic for
you but it's going to be true for

00:02:02.050 --> 00:02:02.550
this cell, too.

00:02:02.550 --> 00:02:03.580
You can work it out for yourself.

00:02:04.830 --> 00:02:07.670
Here, we have a difference.

00:02:07.670 --> 00:02:11.770
So the distance between I, N, T, E and E.

00:02:12.910 --> 00:02:17.520
We could compute that by
taking the distance, but

00:02:17.520 --> 00:02:22.430
it caused us to convert
INTE to nothing and

00:02:22.430 --> 00:02:27.988
then add another searching for E but
that would be silly because 4+1=5 and

00:02:27.988 --> 00:02:32.400
there is a cheaper way to
get from INTE to E and

00:02:32.400 --> 00:02:36.940
that is that it caused us nothing
to march this E to that E.

00:02:36.940 --> 00:02:40.580
So, our previous alignment between I and
T and

00:02:40.580 --> 00:02:44.750
nothing, we can add zero
from three to get a three.

00:02:44.750 --> 00:02:49.700
So, the minimum path for this three,
came from that three so,

00:02:49.700 --> 00:02:53.380
while in some cases from
many places in this case.

00:02:53.380 --> 00:02:58.380
It unambiguously came from this previous
three, and so we're going to do this for

00:02:58.380 --> 00:03:02.480
every array, and
the result will look something like this.

00:03:02.480 --> 00:03:06.200
Where we have for every cell every
place it could have come from.

00:03:06.200 --> 00:03:09.540
You'll see that in a lot of cases
any path could have worked.

00:03:09.540 --> 00:03:15.110
So this 6 could have come from any place,
but crucially this final alignment

00:03:15.110 --> 00:03:20.900
this 8 that tells us the final edit
distance between tension and execution.

00:03:20.900 --> 00:03:26.490
Our trace back tells us it came from
the best alignment between intense O and

00:03:26.490 --> 00:03:30.600
execute O, which came from the best
alignment from intense I and

00:03:30.600 --> 00:03:32.280
execute I and so on.

00:03:32.280 --> 00:03:36.880
And so we can trace back this alignment
and get ourselves an alignment that tells

00:03:36.880 --> 00:03:44.010
us that this n match this n and
this o match this o and so on.

00:03:44.010 --> 00:03:51.390
But maybe here we have an insertion
rather than a clean lining up.

00:03:51.390 --> 00:03:53.300
Computing the backtrace, very simple.

00:03:54.650 --> 00:03:58.310
We take our same minimum edit
distance algorithm that we have seen.

00:03:58.310 --> 00:04:01.150
And here,
I have labelled the cases for you.

00:04:01.150 --> 00:04:04.380
So, when we are looking at a cell
we are deleting, inserting or

00:04:04.380 --> 00:04:07.910
substituting and we simply add pointers.

00:04:07.910 --> 00:04:10.740
So, in the case where we
are inserting we point left.

00:04:10.740 --> 00:04:12.860
In the case where we are deleting,
we point down.

00:04:12.860 --> 00:04:16.052
In the case where we are substituting
we point diagonally I have shown you

00:04:16.052 --> 00:04:17.578
the arrows on the previous slide.

00:04:23.117 --> 00:04:27.560
So we can look at this distance matrix and

00:04:27.560 --> 00:04:35.430
think about the paths from the origin,
here to the end of the matrix.

00:04:35.430 --> 00:04:39.725
And any non decreasing path that
goes from the origin to the point

00:04:39.725 --> 00:04:45.210
N,M corresponds to some
alignment of the two sequences.

00:04:50.210 --> 00:04:55.160
An optimal alignment then is
composed of optimal subsequences,

00:04:55.160 --> 00:04:59.320
and that's the idea that makes it possible
to use dynamic programming for this task.

00:04:59.320 --> 00:05:03.360
So the resulting of our backtrace

00:05:03.360 --> 00:05:07.530
are two strings and
then the alignment between them so

00:05:07.530 --> 00:05:13.870
we will know which things line up exactly,
which things line up with substitutions.

00:05:13.870 --> 00:05:16.190
And then when we should have insertions,
or deletions.

00:05:19.050 --> 00:05:20.710
What's the performance of this algorithm?

00:05:22.440 --> 00:05:28.160
In time, it's order nm,
because our distance matrix is of size nm,

00:05:28.160 --> 00:05:32.220
and we're filling in each cell one time.

00:05:32.220 --> 00:05:37.270
The same is true for space, and
then the back trace, we have to

00:05:38.670 --> 00:05:44.630
and in the worst case go for
if we had n deletions and m insertions.

00:05:44.630 --> 00:05:49.350
We would have to go n plus m,
with the touch n plus m cells but

00:05:49.350 --> 00:05:50.010
not more than that.

00:05:51.410 --> 00:05:53.910
So that's our Backtrace algorithms for
computing alignments.

