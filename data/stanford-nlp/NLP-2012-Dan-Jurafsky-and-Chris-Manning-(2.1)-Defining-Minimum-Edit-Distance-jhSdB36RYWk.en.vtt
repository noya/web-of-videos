WEBVTT
Kind: captions
Language: en

00:00:01.250 --> 00:00:04.870
Let's begin our discussion of minimum
edit distance by defining minimum

00:00:04.870 --> 00:00:05.800
edit distance.

00:00:05.800 --> 00:00:10.200
Minimum edit distance is a way of solving
the problem of string similarity.

00:00:11.490 --> 00:00:13.120
How similar are two strings.

00:00:13.120 --> 00:00:15.508
So, let's pick a particular example,
spell correction.

00:00:15.508 --> 00:00:18.630
The user typed G-R-A-F-F-E.

00:00:18.630 --> 00:00:19.930
What do they really mean?

00:00:19.930 --> 00:00:23.990
And one way of operationalizing this
question is asking which of the following

00:00:23.990 --> 00:00:29.030
words is closer to
the letters that they typed.

00:00:29.030 --> 00:00:31.610
Graf, graft, grail, or giraffe.

00:00:32.750 --> 00:00:36.560
The problem of string similarity comes
up also in computational biology.

00:00:36.560 --> 00:00:42.288
Where we have sequences of nucleotides,
ACGT we're trying to align.

00:00:42.288 --> 00:00:46.785
And a good alignment should be able to
tell us that two particular sequences,

00:00:46.785 --> 00:00:51.830
perhaps from two samples line up in
a certain way with some amount of error.

00:00:51.830 --> 00:00:53.480
And this idea of string similarity or

00:00:53.480 --> 00:00:56.515
sequence similarity comes up
from machine translation, for

00:00:56.515 --> 00:01:00.995
information extraction, for
speech recognition, comes up everywhere.

00:01:00.995 --> 00:01:02.495
So let's define edit distance.

00:01:02.495 --> 00:01:06.970
The minimum edit distance between two
strings is the minimum number of editing

00:01:06.970 --> 00:01:09.276
operations, insertion, deletion and

00:01:09.276 --> 00:01:13.033
substitution, that are needed
to transform one into the other.

00:01:13.033 --> 00:01:17.132
And we generally use these three
editing operations in search and

00:01:17.132 --> 00:01:19.006
deletion and substitution.

00:01:19.006 --> 00:01:22.291
You can imagine more
complicated trans positions and

00:01:22.291 --> 00:01:25.510
long distance movements but
we tend to avoid those.

00:01:26.750 --> 00:01:31.180
So, for example we have the string
in tension and the string execution.

00:01:31.180 --> 00:01:36.040
Here's an alignment showing that
many of the letters line up.

00:01:36.040 --> 00:01:37.850
And with some substitutions and

00:01:37.850 --> 00:01:43.910
then there were some gaps where a gap here
lines up with a letter C in execution and

00:01:43.910 --> 00:01:47.160
a gap in execution lines up with
letter I in intention and so on.

00:01:51.190 --> 00:01:54.430
So, we can think about this alignment

00:01:54.430 --> 00:01:58.120
as having a set of operations
that generated the alignment.

00:01:58.120 --> 00:02:04.910
So here, to turn intention into execution,
we have to delete, d for delete, an i.

00:02:04.910 --> 00:02:07.730
We substitute an N for
an E, substitute a T for

00:02:07.730 --> 00:02:12.740
an X, insert a C, substitute an N for
U and the rest of the letters,

00:02:12.740 --> 00:02:17.400
the E, the T, I, O, N are all the same.

00:02:17.400 --> 00:02:22.460
So the edit distance,
if each operation is 1, is 5.

00:02:22.460 --> 00:02:25.300
We had to do 5 things to turn
intention into execution.

00:02:27.440 --> 00:02:30.940
If substitutions cost 2,
this is called Levenshtein distance.

00:02:30.940 --> 00:02:36.536
In Levenshtein distance,
insertions and deletions cost 1 but

00:02:36.536 --> 00:02:43.178
substitutions cost 2 and now the distance
between these two strings is 8.

00:02:43.178 --> 00:02:47.538
In computational biology,
we've seen sequences of bases, and

00:02:47.538 --> 00:02:52.150
our job is to figure out that this
A aligns to this A and this G to this G.

00:02:53.430 --> 00:02:59.920
And maybe this T A and
T and C A C and so on.

00:02:59.920 --> 00:03:04.100
So this C to here, so we can see that
there's some kind of insertion there.

00:03:04.100 --> 00:03:09.116
And we can represent again
that alignment between

00:03:09.116 --> 00:03:14.738
characters by showing this
aligned string of symbols.

00:03:14.738 --> 00:03:18.520
So the task is given two sequences,
align each letter to a letter on a gap,

00:03:18.520 --> 00:03:20.050
that's our task in biology.

00:03:22.700 --> 00:03:24.748
Edit distance comes up all over the place.

00:03:24.748 --> 00:03:27.645
In machine translation for example,

00:03:27.645 --> 00:03:33.030
we'd like to measure how well
a machine translation system does.

00:03:33.030 --> 00:03:37.254
So let's suppose that our
machine translation system

00:03:37.254 --> 00:03:41.938
represented some sentence maybe
translated from Chinese as

00:03:41.938 --> 00:03:46.088
the spokesman said the senior
adviser was shot dead.

00:03:46.088 --> 00:03:50.922
And some human expert translator
said it should have been spokesmen

00:03:50.922 --> 00:03:54.250
confirm senior government
adviser was shot.

00:03:54.250 --> 00:03:56.980
So we can measure the difference
between these two

00:03:56.980 --> 00:04:01.870
by saying how many words changed
confirms was substituted with said.

00:04:01.870 --> 00:04:06.189
Words that were inserted,
the and words and dead and

00:04:06.189 --> 00:04:09.338
words that were deleted government.

00:04:09.338 --> 00:04:13.629
So a way of measuring how good are machine
translation is by comparing it to humans.

00:04:15.870 --> 00:04:18.941
Similarly, in tasks like
named entity extraction,

00:04:18.941 --> 00:04:22.627
we're going to want to know if IBM Inc and
IBM are the same entity, or

00:04:22.627 --> 00:04:26.588
if Stanford University President
John Hennessy is the same entity as

00:04:26.588 --> 00:04:28.728
Stanford President John Hennessy.

00:04:28.728 --> 00:04:32.352
And we can do that by using edit distance
to notice that these are very similar with

00:04:32.352 --> 00:04:34.940
one word different, and
here one word different.

00:04:34.940 --> 00:04:39.360
And so by measuring the number of
words different, we can improve our

00:04:39.360 --> 00:04:44.390
accuracy at main density extraction and
other kinds of tasks.

00:04:44.390 --> 00:04:47.720
All right, so how are we going to
find this minimum edit distance?

00:04:47.720 --> 00:04:51.330
Our intuition for
the algorithm is to search for a path, and

00:04:51.330 --> 00:04:56.240
by path we mean a sequence of edits,
from the start string to the final string.

00:04:56.240 --> 00:04:57.940
So we'll start with an initial state.

00:04:57.940 --> 00:05:00.890
So that will be the word
we're transforming.

00:05:00.890 --> 00:05:02.080
We'll have a set of operators.

00:05:02.080 --> 00:05:04.398
Insertion, deletion, substitution.

00:05:04.398 --> 00:05:05.518
And we'll have a goal state.

00:05:05.518 --> 00:05:07.838
That's the word we're trying to get to.

00:05:07.838 --> 00:05:10.638
And finally, we'll have a cost for
the path of getting there, and

00:05:10.638 --> 00:05:12.650
that's the thing we're trying to minimize.

00:05:12.650 --> 00:05:15.260
So that's the number of edits,
that's our path cost.

00:05:15.260 --> 00:05:19.890
So for example, from intention,
here's a piece of a path.

00:05:19.890 --> 00:05:23.470
From intention we could delete
a letter and end up with ntention.

00:05:23.470 --> 00:05:25.830
We could insert a letter and
end up with eintention.

00:05:25.830 --> 00:05:29.270
Or we could substitute a letter and
end up with entention.

00:05:29.270 --> 00:05:34.400
So these are pieces along a path
that would go from intention,

00:05:34.400 --> 00:05:38.430
all the way off the screen here into
all the possible ways you can transform

00:05:38.430 --> 00:05:39.370
intention into something.

00:05:42.120 --> 00:05:45.420
So this space of all possible
sequences is enormous.

00:05:45.420 --> 00:05:48.750
So we can't afford to navigate
naively in this sequence.

00:05:50.250 --> 00:05:55.560
And the intuition of solving this
problem of lots of possible sequences

00:05:55.560 --> 00:05:58.820
is that lots of these paths
wind up at the same state.

00:05:58.820 --> 00:06:02.790
So we don't have to keep track of every
way of transforming one string into

00:06:02.790 --> 00:06:07.150
another if the second pieces of
the second string are identical.

00:06:07.150 --> 00:06:11.930
All we have to keep is the shortest
path to every revisited state.

00:06:11.930 --> 00:06:14.360
So let's look at an example
of how this works.

00:06:14.360 --> 00:06:18.780
We're going to define minimum edit
distance formerly as, for two strings

00:06:19.870 --> 00:06:24.070
we have string x of length n and
string y of length m.

00:06:26.010 --> 00:06:31.408
We'll define a distance
matrix capital D of i,j.

00:06:31.408 --> 00:06:37.492
And that would be the edit distance
between the first i characters

00:06:37.492 --> 00:06:43.810
1 through i of x and the first j
character is 1 through j of string y.

00:06:45.100 --> 00:06:51.030
So, that's what's defined by d of j.

00:06:51.030 --> 00:06:55.796
And so the distance between the entire two
strings in going to be D of n command,

00:06:55.796 --> 00:06:58.190
because the strings are length n,m.

00:07:02.036 --> 00:07:04.330
So that's our definition
of Minimum Edit Distance.

