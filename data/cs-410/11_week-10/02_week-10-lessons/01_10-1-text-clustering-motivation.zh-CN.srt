1
00:00:00,012 --> 00:00:07,427
这次讲座

2
00:00:07,427 --> 00:00:10,460
是关于文本聚类的第一讲

3
00:00:14,165 --> 00:00:17,400
在这一讲中 我们将会讨论文本聚类

4
00:00:18,430 --> 00:00:24,590
文本聚类是进行话题挖掘和分析的至关重要的工具

5
00:00:24,590 --> 00:00:25,100
在 bootstrap 中

6
00:00:25,100 --> 00:00:30,430
在这一讲中我们将对聚类的一些基本问题展开讨论

7
00:00:31,650 --> 00:00:37,040
这些问题包括文本聚类的定义以及研究文本聚类的动机

8
00:00:38,060 --> 00:00:42,610
在后续的讲座我们将会讨论如何进行文本聚类

9
00:00:42,610 --> 00:00:44,550
以及如何评价聚类的结果

10
00:00:47,060 --> 00:00:48,400
那么 什么是文本聚类呢

11
00:00:49,500 --> 00:00:52,640
可能你在其他课程已经了解到

12
00:00:52,640 --> 00:00:55,670
聚类是数据挖掘中十分常用的工具

13
00:00:56,760 --> 00:01:00,250
聚类的意图是发现数据的内在结构

14
00:01:01,250 --> 00:01:05,040
换句话说 我们希望将相似的对象聚集起来

15
00:01:05,040 --> 00:01:09,170
在这里 对象特指文本对象

16
00:01:09,170 --> 00:01:14,510
例如 这些对象可以是文档 术语 文章...

17
00:01:14,510 --> 00:01:21,510
语句或者网页 然后我将会把相似的文本聚集到一起

18
00:01:21,510 --> 00:01:26,560
让我们看一个例子 在这一例子中没有使用文本对象 

19
00:01:26,560 --> 00:01:31,560
我会用一些图形来表示可用于分组的对象

20
00:01:33,450 --> 00:01:39,690
如果我问你这个例子中有什么内在的结构或分组

21
00:01:39,690 --> 00:01:47,790
当你观察了这个例子后你可能会赞同将这些对象按形状

22
00:01:47,790 --> 00:01:51,740
或者他们在这个二维空间的位置分类

23
00:01:53,240 --> 00:01:55,110
所以根据空间分类我们得到了三类

24
00:01:56,940 --> 00:02:01,360
对于所得的三个聚类可能大多数人不认同

25
00:02:01,360 --> 00:02:06,220
不过对于聚类的评价往往取决于看待对象的角度

26
00:02:07,650 --> 00:02:11,450
如果有人从不同的视角进行分类

27
00:02:11,450 --> 00:02:14,050
也许就会得到其他的聚类结果

28
00:02:14,050 --> 00:02:21,400
关于聚类的模糊性在另外的例子中会详细地描述

29
00:02:21,400 --> 00:02:27,440
在这里只是希望强调聚类问题并没有被明确定义

30
00:02:29,200 --> 00:02:34,130
问题的根源在于如何界定相似性

31
00:02:34,130 --> 00:02:36,220
相似的对象究竟代表了什么意义呢

32
00:02:38,160 --> 00:02:40,990
为了清晰地定义聚类

33
00:02:40,990 --> 00:02:44,537
这个问题必须有一个清晰的答案

34
00:02:46,315 --> 00:02:49,295
但是解答这个问题的困难在于 一般而言

35
00:02:49,295 --> 00:02:53,445
从特定的角度入手 任意两个对象都是相似的

36
00:02:53,445 --> 00:02:59,119
例如 以车和马两个字为例子

37
00:03:00,300 --> 00:03:02,650
这两个字是否相似呢

38
00:03:02,650 --> 00:03:08,490
答案有各种可能 如果我们对比...

39
00:03:11,070 --> 00:03:16,000
车和马的物理属性 那么他们的区别相当明显

40
00:03:16,000 --> 00:03:20,630
但如果你对比他们的功能

41
00:03:20,630 --> 00:03:23,650
车和马都能视为运输工具

42
00:03:23,650 --> 00:03:26,220
从这个意义上说 它们是类似的

43
00:03:26,220 --> 00:03:31,599
正如我们所见 对象的相似性取决于看待这些对象的角度

44
00:03:32,740 --> 00:03:37,700
因此聚类问题可以被明确定义了

45
00:03:37,700 --> 00:03:43,050
用户必须定义从什么角度判断相似性

46
00:03:44,310 --> 00:03:47,599
这个角度称为聚类偏差

47
00:03:49,270 --> 00:03:54,180
当你定义聚类问题时 指定如何界定相似性

48
00:03:55,340 --> 00:04:00,870
或用于对相似的对象进行分组的相似性

49
00:04:00,870 --> 00:04:05,830
是十分重要的

50
00:04:05,830 --> 00:04:11,795
因为如果不这样做 相似性就没有清晰的定义

51
00:04:11,795 --> 00:04:16,870
给对象进行分类就会有很多不同的方法

52
00:04:16,870 --> 00:04:19,910
让我们看一个例子

53
00:04:19,910 --> 00:04:24,210
现在有一些对象 或者说一些图形

54
00:04:24,210 --> 00:04:29,730
他们跟你在第一张幻灯片所见的图形十分相似

55
00:04:29,730 --> 00:04:34,430
但如果我再次要求你对他们进行分类

56
00:04:38,040 --> 00:04:42,052
你可能会觉得比前一张幻灯片思考得更多

57
00:04:42,052 --> 00:04:47,810
例如你可能会想

58
00:04:47,810 --> 00:04:53,510
我们可以根据形状进行组合 由此产生这样的聚类结果

59
00:04:53,510 --> 00:04:57,558
不过 你可能觉得

60
00:04:57,558 --> 00:05:02,380
这些对象可以根据他们的尺寸进行组合

61
00:05:02,380 --> 00:05:07,020
所以通过对比他们的尺寸以及尺寸的相似性

62
00:05:07,020 --> 00:05:11,890
我们产生了另外一种聚类的方法

63
00:05:12,910 --> 00:05:16,440
由此可见 根据不同的判断角度

64
00:05:16,440 --> 00:05:18,860
会得到不同的聚类结果

65
00:05:18,860 --> 00:05:23,750
另外这也提醒我们 要评价聚类结果

66
00:05:23,750 --> 00:05:27,060
我们必须考虑聚类的角度

67
00:05:27,060 --> 00:05:32,054
否则 定义最优的聚类结果将会十分困难

68
00:05:36,152 --> 00:05:40,970
文本聚类的例子数不胜数

69
00:05:42,330 --> 00:05:48,380
例如 在一个文本的集合中对文档进行聚类

70
00:05:48,380 --> 00:05:51,269
在这个例子中 文档是进行聚类的单位

71
00:05:52,280 --> 00:05:55,780
我们也能对术语进行聚类

72
00:05:55,780 --> 00:05:58,300
这种情况下 术语就是对象

73
00:05:58,300 --> 00:06:03,480
术语的聚类可用于定义 概念 主题 或话题

74
00:06:03,480 --> 00:06:08,530
事实上 前面的讲座提及的一个话题模型

75
00:06:08,530 --> 00:06:13,850
可以让你的术语聚类在一定程度上发挥作用

76
00:06:13,850 --> 00:06:19,610
只要你从词语库中选取了出现概率高的术语

77
00:06:19,610 --> 00:06:25,330
另一个例子是对一些文本片段进行聚类  例如文章

78
00:06:25,330 --> 00:06:30,970
句子 或其他可以从可以从较大的 文本对象提取的片段

79
00:06:32,100 --> 00:06:36,300
例如 假设我们使用一个话题模型

80
00:06:36,300 --> 00:06:39,030
来提取和这个话题相关的文本

81
00:06:39,030 --> 00:06:43,620
一旦我们得到了这样的文本对象

82
00:06:45,120 --> 00:06:50,850
我们就能对它们进行聚类

83
00:06:50,850 --> 00:06:56,908
观察是否产生了值得深入探究的聚类结果

84
00:06:56,908 --> 00:07:00,860
这是一个将文本聚类和其他技术手段结合的例子

85
00:07:00,860 --> 00:07:03,762
一般来说 你会发现 大部分的文本聚类

86
00:07:05,140 --> 00:07:09,670
被灵活运用时 可以准确地完成

87
00:07:09,670 --> 00:07:14,840
复杂的文本数据挖掘与分析

88
00:07:16,030 --> 00:07:20,070
当然 我们也可以对相当大型的文本对象进行聚类

89
00:07:20,070 --> 00:07:24,600
而所谓的大型文本对象可能包括了大量的文档

90
00:07:24,600 --> 00:07:27,440
例如 我们可能对网站进行聚类

91
00:07:27,440 --> 00:07:31,228
而每一个网页实际上是由数个文档构成的

92
00:07:31,228 --> 00:07:39,065
类似的 我们也能对出自同一作家的文章进行聚类

93
00:07:39,065 --> 00:07:44,573
我们可以把某个作家的所有文章当作一个聚类...

94
00:07:44,573 --> 00:07:45,785

95
00:07:45,785 --> 00:07:50,652
这样 我们就可以根据是否发表过论文或其他学术成果

96
00:07:50,652 --> 00:07:52,770
把作者进行分类

97
00:07:55,150 --> 00:08:00,290
文本聚类的结果还可以再进行聚类 从而形成层次结构

98
00:08:00,290 --> 00:08:06,330
因为一般而言我们可以在不同的层次进行聚类

99
00:08:08,210 --> 00:08:11,750
那么为什么文本聚类值得研究呢

100
00:08:11,750 --> 00:08:16,100
因为它是进行文本挖掘的十分有用的工具

101
00:08:16,100 --> 00:08:18,710
特别是进行探究性的文本分析

102
00:08:20,250 --> 00:08:25,690
很多时候 你得到大量文本数据

103
00:08:25,690 --> 00:08:30,300
例如某段时间内来自顾客的所有邮件

104
00:08:30,300 --> 00:08:32,070
或者所有文学作品 诸如此类

105
00:08:32,070 --> 00:08:35,960
然后你希望大致了解这些文本包含了什么内容

106
00:08:35,960 --> 00:08:40,970
例如 你可能想知道主要的话题

107
00:08:40,970 --> 00:08:45,910
或者在这些文本中典型的

108
00:08:45,910 --> 00:08:49,360
有代表性的文档是哪些

109
00:08:49,360 --> 00:08:53,164
聚类可以帮助我们实现这些目标

110
00:08:53,164 --> 00:08:59,949
有时候我们希望把相似的文本对象关联起来

111
00:08:59,949 --> 00:09:03,960
例如 这样的文本对象可能是冗余的内容

112
00:09:03,960 --> 00:09:04,830
这个投票机制下

113
00:09:04,830 --> 00:09:09,560
文本聚类就能帮助我们消除冗余

114
00:09:10,910 --> 00:09:13,280
有时候 这些文本可能与同一个话题有关

115
00:09:13,280 --> 00:09:17,140
通过关联这些文本 可以比较全面地了解这个话题

116
00:09:19,660 --> 00:09:24,420
我们也能用文本聚类将文本数据结构化

117
00:09:24,420 --> 00:09:28,840
有时还能建立结构的层次关系 而这对博客尤其有用

118
00:09:31,270 --> 00:09:36,140
我们还能利用文本聚类给文本数据增添额外的特性

119
00:09:36,140 --> 00:09:40,206
在对文档进行聚类之后 我们可以将每一类视为一个特征

120
00:09:40,206 --> 00:09:44,100
那么假设一个文档在这一类中

121
00:09:44,100 --> 00:09:45,790
我们就可以说它对应的特征值是1

122
00:09:45,790 --> 00:09:49,870
如果一个文档不在这一类中 那么对应的特征值是0

123
00:09:49,870 --> 00:09:54,298
这种方法提供了进行文本分类的一种区分方式

124
00:09:54,298 --> 00:09:57,900
我们将在后续的课程进行详细讨论

125
00:09:59,870 --> 00:10:03,320
一般而言 文本聚类的应用十分广泛

126
00:10:03,320 --> 00:10:06,218
我只想到两个十分特殊的应用场景

127
00:10:06,218 --> 00:10:08,490
一是搜索结果聚类

128
00:10:08,490 --> 00:10:12,360
例如 搜索引擎可以将搜索结果聚类

129
00:10:12,360 --> 00:10:19,020
这样用户就可以看到查询结果的大致结构

130
00:10:19,020 --> 00:10:22,454
当查询条件比较模糊时 聚类会非常有用

131
00:10:22,454 --> 00:10:26,710
因为它们会呈现模糊词汇的不同意义

132
00:10:28,630 --> 00:10:33,535
另一项应用是通过顾客的邮件

133
00:10:33,535 --> 00:10:34,943
了解他们的主要诉求

134
00:10:34,943 --> 00:10:40,238
这种情况下 我们对邮件进行聚类

135
00:10:40,238 --> 00:10:44,903
然后找到主要的一类

136
00:10:44,903 --> 00:10:51,355
从这一类中 我们就能知道顾客的主要诉求了

137
00:10:51,355 --> 00:10:57,897
[背景音乐]
翻译: RyukaSuu |审阅: 19waa
Coursera Global Translator Community