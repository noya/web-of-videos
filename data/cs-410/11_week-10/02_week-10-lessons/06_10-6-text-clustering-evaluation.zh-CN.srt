1
00:00:00,000 --> 00:00:06,538
[背景音乐]
翻译: RyukaSuu |审阅: 19waa
Coursera Global Translator Community

2
00:00:06,538 --> 00:00:10,520
这节课是关于文本聚类评估

3
00:00:12,830 --> 00:00:18,240
现在为止讨论过文本聚类的多种方法
但是

4
00:00:18,240 --> 00:00:21,430
到底如何知晓哪种方法最好

5
00:00:22,950 --> 00:00:25,540
这就需要评估

6
00:00:25,540 --> 00:00:28,030
现在要讲讲评估 必须得

7
00:00:28,030 --> 00:00:31,480
回到开始介绍的聚类基础

8
00:00:32,560 --> 00:00:36,770
因为根据如何看待它们 
两个样本可以相似

9
00:00:37,780 --> 00:00:41,910
我们必须清楚地指明相似的视角

10
00:00:41,910 --> 00:00:46,200
不这么做
就不能很好的定义聚类问题

11
00:00:46,200 --> 00:00:51,740
所以这个视点对于评估也很重要

12
00:00:51,740 --> 00:00:53,350
这帧幻灯片里

13
00:00:53,350 --> 00:00:58,830
可以看到针对这些图形有两种不同的聚类方法

14
00:00:58,830 --> 00:01:03,640
如果提问 哪个最好 或者哪个更好

15
00:01:03,640 --> 00:01:07,860
实际上发现没办法回答这个问题
如果不知道

16
00:01:07,860 --> 00:01:13,420
要根据形状聚类
还是根据大小

17
00:01:13,420 --> 00:01:17,480
精确地说就是 
为什么聚类偏差

18
00:01:17,480 --> 00:01:18,680
对于评估是至关重要的

19
00:01:19,710 --> 00:01:23,530
笼统来说 我们有两种方法来评估文本聚类

20
00:01:23,530 --> 00:01:27,580
一个是直接评估
另一个是间接

21
00:01:27,580 --> 00:01:29,310
那么在直接评估里

22
00:01:29,310 --> 00:01:34,060
需要回答如下问题
系统生成的

23
00:01:34,060 --> 00:01:37,150
基于理想的聚类的聚类和人类做出的有多相近

24
00:01:38,580 --> 00:01:43,040
这里可以看到的相近度

25
00:01:44,420 --> 00:01:50,330
就是从多重视点得到的
并且帮助我们表征质量

26
00:01:50,330 --> 00:01:55,320
从多种角度来表示聚类结果的特征
这有时候是需要的

27
00:01:56,790 --> 00:02:04,010
现在还想要知道量化相近度
因为这样可以

28
00:02:04,010 --> 00:02:08,500
使我们轻松比较不同的度量
根据它们的表象

29
00:02:09,870 --> 00:02:14,630
最后 可以看到 这个例子里
我们是要拒绝聚类偏差的

30
00:02:15,660 --> 00:02:21,660
用人类自己的方法
基本上我们需要

31
00:02:21,660 --> 00:02:24,260
或者必要的聚类偏差

32
00:02:24,260 --> 00:02:25,610
到底具体怎么做

33
00:02:25,610 --> 00:02:27,519
一般手段是像这样的

34
00:02:28,590 --> 00:02:33,290
一个测试组 其中包含了大量文本

35
00:02:33,290 --> 00:02:37,100
我们可以找人来做出理想的聚类结果
就是说

36
00:02:37,100 --> 00:02:42,390
我们打算让人类自己来制定黄金规则

37
00:02:42,390 --> 00:02:48,490
并且判断 
根据某个特定应用的需要

38
00:02:48,490 --> 00:02:54,470
来生成他们自己认为最完美的聚类结果
这样会

39
00:02:54,470 --> 00:02:59,990
在接下来被用来比较系统生成的聚类
用同样的实验组

40
00:03:01,380 --> 00:03:05,700
理想状况下
想要系统结果和人类自己的结果一样

41
00:03:05,700 --> 00:03:08,650
但事实上 通常它们不可能一样

42
00:03:08,650 --> 00:03:12,590
所以我们就需要量化相似性
系统生成的

43
00:03:12,590 --> 00:03:15,410
聚类和黄金规则下的聚类

44
00:03:15,410 --> 00:03:20,110
这个相似度可以被用来在多种视角下度量

45
00:03:20,110 --> 00:03:26,750
将会在量化评估一个聚类时得到多重网格
一个聚类结果

46
00:03:26,750 --> 00:03:34,140
一些常用的测量包括了纯度
它测量了

47
00:03:34,140 --> 00:03:40,015
一个聚类是否从同样的聚类得到相似的样本
在黄金规则下

48
00:03:40,015 --> 00:03:45,545
同时归一化互信息也是常用的测量

49
00:03:45,545 --> 00:03:50,485
它基本上根据身份来测量

50
00:03:50,485 --> 00:03:54,935
样本聚类在系统里的身份

51
00:03:54,935 --> 00:04:00,225
到底如何预测在黄金规则下样本的聚类

52
00:04:00,225 --> 00:04:01,440
或者反过来

53
00:04:01,440 --> 00:04:06,315
互化信息捕捉了联系 
聚类标签和

54
00:04:06,315 --> 00:04:11,100
归一互化信息的联系
它常常

55
00:04:11,100 --> 00:04:15,300
被用来量化相似度

56
00:04:15,300 --> 00:04:19,220
为了评估的目的
F-Measure是另一个可能的测量

57
00:04:21,340 --> 00:04:24,405
这个评估的完整讨论

58
00:04:24,405 --> 00:04:28,810
和这些评估的问题超过了这门课讨论的范围

59
00:04:29,820 --> 00:04:34,730
我建议课程结束后多读些东西
就能

60
00:04:34,730 --> 00:04:35,840
多了解

61
00:04:36,950 --> 00:04:39,830
这里我想要讨论一些高级的主题

62
00:04:39,830 --> 00:04:43,830
可以让你思考如何评估自己的应用

63
00:04:43,830 --> 00:04:48,120
第二个方法是评估文本聚类就是间接评估

64
00:04:48,120 --> 00:04:52,540
这样的话问题答案就是
这些评估结果有多游泳

65
00:04:52,540 --> 00:04:55,120
为了目标应用

66
00:04:55,120 --> 00:04:59,730
当然了 是特定问题的应用
所以说

67
00:04:59,730 --> 00:05:05,390
用处取决于特定的应用

68
00:05:07,140 --> 00:05:11,180
聚类偏差也是从独立应用

69
00:05:11,180 --> 00:05:12,850
得来的 所以

70
00:05:12,850 --> 00:05:17,790
一个好的聚类结果
取决于应用

71
00:05:19,098 --> 00:05:25,120
现在从步骤的角度我们也希望
创造一个由文本样本组成的实验组

72
00:05:25,120 --> 00:05:29,860
用于目标应用中来量化系统的性能

73
00:05:32,880 --> 00:05:38,870
这个例子里
我们关心的是 做了多少

74
00:05:38,870 --> 00:05:43,960
聚类用于某些应用
所以常常是设置一个系统基准线来比较

75
00:05:45,040 --> 00:05:47,670
可以是现存正在使用的系统

76
00:05:47,670 --> 00:05:51,820
然后希望加入一个聚类来进化它

77
00:05:51,820 --> 00:05:55,340
或者基准线系统可以被用于不同的聚类方法

78
00:05:55,340 --> 00:05:59,940
想要实验的东西

79
00:05:59,940 --> 00:06:03,110
和你希望更了解聚类

80
00:06:03,110 --> 00:06:06,911
不管怎样已经有了基准线系统来使用
接下来就是加入聚类

81
00:06:06,911 --> 00:06:10,110
算法来生成聚类系统

82
00:06:11,740 --> 00:06:14,870
然后必须要比较你的聚类系统的性能和

83
00:06:14,870 --> 00:06:18,660
基准线系统的性能

84
00:06:18,660 --> 00:06:19,940
用特定应用的性能测量

85
00:06:21,070 --> 00:06:25,620
所以称之为聚类的间接评估
因为没有

86
00:06:25,620 --> 00:06:30,040
详细的聚类质量的测试

87
00:06:30,040 --> 00:06:35,470
反而是评估某特定应用的聚类的贡献

88
00:06:37,350 --> 00:06:40,570
总结一下文本聚类

89
00:06:41,950 --> 00:06:46,750
它是一种非常有用的无监督通用文本挖掘工具

90
00:06:46,750 --> 00:06:52,860
并且在获得文本整体样貌中特别有用

91
00:06:52,860 --> 00:06:56,960
常常被用来探索文本数据

92
00:06:56,960 --> 00:06:59,910
被用来当成第一步
在处理文本数据时

93
00:07:01,720 --> 00:07:06,610
第二个应用或者说第二种应用就是

94
00:07:06,610 --> 00:07:09,800
通过在文本数据中发现有趣的聚类结构

95
00:07:09,800 --> 00:07:11,660
并且这些结构会非常有意义

96
00:07:13,330 --> 00:07:18,752
有很多方法可以被用来形成文本聚类

97
00:07:18,752 --> 00:07:25,590
我们讨论过的模型基于这些方法

98
00:07:25,590 --> 00:07:30,390
通常来说 强大的聚类不管用什么方法都能得到

99
00:07:30,390 --> 00:07:35,350
并且这种方法的效率取决于不管想要得到的

100
00:07:35,350 --> 00:07:40,400
聚类偏差是否被恰当的截取
都可以完成 通过使用

101
00:07:40,400 --> 00:07:45,150
正确的生成模型
恰当的模型设计

102
00:07:45,150 --> 00:07:49,460
或者正确的相似性方程来定义偏差

103
00:07:49,460 --> 00:07:53,730
决定最优化的客户数目是一个非常难得问题

104
00:07:53,730 --> 00:07:59,510
在顺序聚类方法中 
因为这是一种无监督算法

105
00:07:59,510 --> 00:08:03,885
而且没有培训可以教你如何选择最佳的聚类数目

106
00:08:05,125 --> 00:08:08,515
有时候你可能看到一些方法可以自动决断

107
00:08:08,515 --> 00:08:13,575
聚类的数目
但通常是使用了某些

108
00:08:13,575 --> 00:08:18,135
聚类偏差的应用
而且不是指定的

109
00:08:18,135 --> 00:08:23,900
如果不能很好的定义聚类偏差
就不可能得到

110
00:08:23,900 --> 00:08:30,860
最优化的聚类数目
所以要记住这点

111
00:08:31,920 --> 00:08:35,650
有时候我们可以使用应用来得到

112
00:08:35,650 --> 00:08:39,320
聚类数目 比如说
你要聚类搜索结果

113
00:08:39,320 --> 00:08:43,340
那么明显的你不想要生成100个

114
00:08:43,340 --> 00:08:45,870
所以这个数目可以通过接口设计来获得

115
00:08:46,880 --> 00:08:53,470
其他情况下
我们可能可以使用美化数据

116
00:08:53,470 --> 00:08:59,440
来衡量是否得到了一个合适的聚类数目
来好好解释数据

117
00:08:59,440 --> 00:09:04,330
这么做就得有多个聚类数目

118
00:09:04,330 --> 00:09:06,170
并且观察有多合适数据

119
00:09:07,430 --> 00:09:10,740
通常当你增加一些部件到混合型模型里
就可以

120
00:09:10,740 --> 00:09:13,100
更好的契合数据 因为你 你不这么做

121
00:09:13,100 --> 00:09:17,350
一般可以设定使用新零件的概率为0

122
00:09:17,350 --> 00:09:23,930
所以你不能使数据契合更糟糕 比起以前
但问题是

123
00:09:23,930 --> 00:09:28,350
当你添加更多零件就可以显著提升契合度

124
00:09:28,350 --> 00:09:33,890
可以用来决定合适的聚类数目

125
00:09:33,890 --> 00:09:36,610
最终的聚类结果评估

126
00:09:36,610 --> 00:09:41,560
可以用过直接和间接的方法 
常常我们需要

127
00:09:41,560 --> 00:09:46,590
两个都用 为了得到到底哪个方法更好用

128
00:09:46,590 --> 00:09:52,206
这里有些建议的阅读
特别有用

129
00:09:52,206 --> 00:09:58,838
用来理解匹配是如何计算和匹配的

130
00:09:58,838 --> 00:10:08,838
[背景音乐]
翻译: RyukaSuu |审阅: 19waa
Coursera Global Translator Community